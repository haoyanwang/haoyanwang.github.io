---
title: 从字段联动中学图算法
top: false
cover: false
toc: true
mathjax: true
date: 2023-02-01 13:42:17
password:
summary:
tags:
categories:
---

# 初识
字段联动是很常见的表单需求

最基本的是主动模式联动显示，即表单项决定其他表单项的显示和隐藏，使用效果例如：

请选择您要申请的职位

    - if 前端 请选择您使用的技术框架： Vue React Angular
    - else if 后端 请选择您使用的语言： Java Python PHP

当然除了主动模式，还有被动模式，即表单项被其他表单项决定

除了联动显示，还可能有联动禁用、联动只读等

## 直觉code，best code
业务现存的表单结构为: {题目合集: [{标题、类型、结果、选项}, {标题、类型、结果、选项}]}

因为数据结构为数组，所以第一反应就是遍历，根据联动关系，算出题目是隐藏还是显示。并设计出了主动模式下的联动关系的数据结构:

```
// - 当题目1的value为A时，显示题目2、当题目1的value为B时，显示题目3
// - 当题目2的value为A时，显示题目3

[{id: '1', linkages: [{id: '2', value: A, id: '3', value: B}]}, {id: '2', linkages: [{id: '3', value: A}]}]
```

于是便写出了第一版实现

    1. 根据主动联动关系，计算出被动联动关系（题目2被题目1的1联动显示。题目3被题目1的2、题目2的1联动显示）
    2. 每次变化时，遍历所有的题目，根据联动关系计算出每一道题是否隐藏（invisible）（只有当有被联动关系，并且被联动关系均不满足，则这道题隐藏）
    
但是很快就遇到了问题，因为遍历是有顺序的（数组从前往后），但联动是没有顺序的，所以单纯的遍历很有可能计算出不对的结果

    eg.

    有1、2、3三道题
    联动关系：
    当2选择A时，显示1
    当3选择A时，显示2、当3选择B时，显示1

    3(A) → 2
    3(B) → 1
    2(A) → 1
    当题目3选择A、题目2选择A时 1、2、3三道题均可见。这时将题目3改为C，题目1、2均应隐藏。
    但因遍历顺序的问题，计算到题目1的时候，题目2仍未计算，仍是可见的。则计算出了错误的结果。即题目1显示、题目2隐藏、题目3为C

于是为了解决上述问题，便有了第二版实现，多层级遍历

即先把题目2是否显示计算出来，再进行一次遍历，将题目1是否显示计算出来。便引出了一个概念：linkageLevel，联动层级

在上述问题中，题目3为1级、题目2为2级、题目1为2级（被题目3联动）或3级（被题目2联动），先计算出题目中的最大联动层级，再进行多次遍历。第一次遍历计算出题目2是否显示，第二次遍历计算出题目1是否显示

但假如存在环状联动，这种方法又遇到了瓶颈，甚至可能会出现死循环

时间复杂度：题目数量为n，最大联动层级为m  O(n^m) 非常恐怖的复杂度

于是考虑从图算法的角度出发，利用拓扑排序去解决计算的问题

## 图论算法实现联动
分析一下联动关系的数据结构，可以发现，其实就是一副有向有环图

其中题目就是图中的节点，联动关系就是边。并且是带方向，可能存在环状的

而我们的需求是，根据联动关系，计算所有题目显示或隐藏，既寻找该数据结构的拓扑排序

可以参考leetcode这道题 https://leetcode.cn/problems/course-schedule-ii/

求拓扑排序分为两种思路：BFS（广度优先遍历）、DFS（深度优先遍历）

有向无环图一定存在拓扑排序，而有向有环图一定不存在拓扑排序，所以我们要先判断图是否有环

广度优先：

    在广度优先遍历中，出入度是核心概念：如果一个节点 x 有 a 条边指向别的节点，同时被 b 条边所指，则称节点 x 的出度为 a，入度为 b
    在联动关系中，入度为0表示不被联动，既无条件显示的题目
     
    算法思路：
    1. 构建一个 indegree 数组记录每个节点的入度，即 indegree[i] 记录节点 i 的入度
    2. 对 BFS 队列进行初始化，将入度为 0 的节点首先装入队列
    3. 开始执行 BFS 循环，不断弹出队列中的节点，减少相邻节点的入度，并将入度变为 0 的节点加入队列
    4.如果最终所有节点都被遍历过（count 等于节点数），则说明不存在环，反之则说明存在环
    5. 最终队列中的节点顺序就是图的拓扑排序
    6. 根据拓扑排序顺序，去求题目是否隐藏，如果有环则把环内节点跳过，并置为不显示

    参考资料及示意图： https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/huan-jian--e36de/#环检测算法bfs-版本

    时间复杂度：n个节点 m条边 O(n+m)


深度优先：

    环检测：从节点开始递归遍历，记录访问过的节点与当前路径。如果节点访问过，则直接跳过，如果当前路径与当前节点有重合，则存在环
    遍历思路：后序遍历反转就是拓扑排序
    个人觉得不如bfs好理解

    参考资料：https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/huan-jian--e36de/#拓扑排序算法dfs-版本


