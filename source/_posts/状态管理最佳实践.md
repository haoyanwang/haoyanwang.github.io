---
title: 状态管理最佳实践
top: false
cover: false
toc: true
mathjax: true
password:
summary:
tags:
categories:
---

# 状态管理最佳实践

写这个的初衷是新项目中使用了 Redux Toolkit，发现自己没用过，看不懂。于是就重新学习了一下 redux 的文档，并结合自己之前做状态管理的经验，写一篇文章

前端的领域有很多，但如果是一只切图仔，那大概率接触最多的就是和各种状态打交道。所以我一直认为，高效的管理前端的状态，是一个很重要且有用的事

本篇文章会包含以下内容：

- [什么是 Redux](#1)、[什么是 Redux Toolkit](#2)
- [一些 Redux 官方推荐实践](#3)
- [什么是 Mobx，和 Redux 有什么区别](#4)
- [复杂组件怎么做状态管理](#5)

<h2 id="1">什么是 Redux<h2>

### Redux 解决了什么问题

Redux 是一个全局状态管理工具，使用了单向数据流，方便在多人协作的复杂项目中写出更容易理解的代码
动机：https://cn.redux.js.org/understanding/thinking-in-redux/motivation

### store

store 是一个存储状态的单例全局对象，通过 redux 的 createStore 或 redux toolkit 的 configureStore 创建，使用 redux Provide 注入

### action

action 是一个具有 type 字段的 JS 对象，可以将 action 视为描述应用程序中发生了什么的事件，通过描述性名称，确保操作是符合预期的
一个典型的 action 对象

```
const addTodoAction = {
  type: 'todos/todoAdded',
  payload: 'Buy milk'
}
```

### dispatch

可以用 dispatch 调用一个 action

### Selector

封装读取 store 的逻辑

### reducer

reducer 是一个函数，可以将 reducer 视为一个事件监听器，它根据接收到的 action（事件）类型处理事件

reducer 的规则：

- 仅使用 state 和 action 参数计算新的状态值
- 禁止直接修改 state。必须通过复制现有的 state 并对复制的值进行更改的方式来做 不可变更新（immutable updates）
- 禁止任何异步逻辑、依赖随机值或导致其他“副作用”的代码

参考文章：https://cn.redux.js.org/tutorials/essentials/part-1-overview-concepts

### Enhancers & Middleware

可以增强 store，自定义 dispatch、getState 和 subscribe。个人理解可以类比 webpack 的 plugin

可以再 redux 中间过程做任何想做的事

```
function exampleMiddleware(storeAPI) {
  return function wrapDispatch(next) {
    return function handleAction(action) {
      // 在这里做任何事情：用 next(action) 向前传递 action，
      // 或者使用 storeAPI.dispatch(action) 重启管线
      // 这里也可以使用 storeAPI.getState()
      return next(action)
    }
  }
}
```

参考文章：https://cn.redux.js.org/tutorials/fundamentals/part-4-store/#middleware

### Redux Thunk Middleware

普通的 redux 只能同步的去 dispatch store，但是因为有了 Middleware 的存在，就可以进行异步操作（如 http 请求）

这样就可以把请求逻辑和 redux 逻辑写在一起，而不是发起请求，拿到回调结果之后，再去 dispatch 一个 action。如果 redux 中存在请求状态、请求请求结果等多个值，就可以将不同逻辑写成一个独立的 action

实例：

```
function saveNewTodoThunk(dispatch) {
    const initialTodo = { text }
    const response = await client.post('/fakeApi/todos', { todo: initialTodo })
    dispatch({ type: 'todos/todoAdded', payload: response.todo })
  }
```

<h2 id="2">什么是 Redux Toolkit<h2>

官方推荐使用 Redux Toolkit

内置了一些新的 API 和 Middleware

东西很多，只捡比较常用的看一看

文档（中文文档翻译不太全）：https://redux-toolkit.js.org/

### createSlice

toolkit 使用 createSlice 替换了 createStore

优点：代码量比较少，可读性好，还可以配置 devTools

示例：

```
// reducer定义
export const counterSlice = createSlice({
  name: 'counter',
  initialState: {
    value: 0,
  },
  reducers: {
    increment: (state) => {
      // Redux Toolkit 允许在reducer中写出 "mutating" 逻辑
      // 它使用了Immer库，实际上做的也是immutable操作
      state.value += 1
    },
    decrement: (state) => {
      state.value -= 1
    },
    incrementByAmount: (state, action) => {
      state.value += action.payload
    },
  },
})

// store定义
const store = configureStore({
  reducer: {
    counter: counterSlice.reducers,
  },
})
```

### createAsyncThunk

被包装过的 Middleware，有一些比较实用的配置项，个人觉得比较有用的是，thunkAPI.requestId（请求唯一 id），thunkAPI.signal（可以取消 dispatch）

```
   const promise = dispatch(fetchUserById(props.userId))
    return () => {
      // createAsyncThunk可以用abort来取消dispatch，取消后，会返回一个thunkName/rejected
      promise.abort()
    }
```

```
// 根据userId，短时间内只能发一次请求
const fetchUserById = createAsyncThunk<User, string, {
    state: { users: { loading: string, currentRequestId: string } }
}> (
  'users/fetchByIdStatus',
  async (userId: string, { getState, requestId }) => {
    const { currentRequestId, loading } = getState().users
    if (loading !== 'pending' || requestId !== currentRequestId) {
      return
    }
    const response = await userAPI.fetchById(userId)
    return response.data
  }
)
```

<h2 id="3">一些 Redux 官方推荐实践</h2>

### TS 类型友好

之前项目中，写一次 useSelector 和 useDispatch 就需要写一次类型，官方文档里建议可以包装一层，把类型兜住

```
// 计算root state的ts类型
export type RootState = ReturnType<typeof store.getState>
export const useAppSelector: TypedUseSelectorHook<RootState> = useSelector

// 计算dispatch的类型
export type AppDispatch = typeof store.dispatch
export const useAppDispatch: () => AppDispatch = useDispatch
```

### 使用 createSelector 减少重渲染

使用 createSelector 创建的结果会被缓存起来，供下次使用（之前的经验来看，这个东西需要设计好，否则可读性比较差）

<h2 id="4">什么是 Mobx，和 Redux 有什么区别</h2>

Mobx 同样也是一个状态管理的库，它有 3 个核心主旨

1. State(状态)
2. Actions(动作)
3. Derivations(派生)

### Mobx 和 Redux 的区别

1. Redux 只有一个全局 store，Mobx 可以声明多个 store
2. 某些领域理念不一样，比如 immutable 和更新视图的方式
3. Mobx 使用起来比 Redux 更简洁

<h2 id="5">复杂组件怎么做状态管理</h2>

做组件的状态管理，重点就是父子组件的通信，这也是 Redux 和 Mobx 尝试解决的问题
我一般有两种理念

1. 受控组件（将状态保持在父组件，并分发下去，子组件可以通过调用父组件的方法，去改变状态）
2. 非受控组件（将状态保持在子组件，父组件通过回调函数，或者是子组件暴露 ref + useImperativeHandle，将子组件实现暴露给父组件）

### 受控组件

假如我们有一个 todoList 组件，在组件里可以显示、编辑 item 的某些字段，比如 name、color，在业务简单的时候，我们可以在一个组件的实现里保持 item 的状态

```
  const [todoList, setTodoList] = useState([
    { name: "1", color: "red" },
    { name: "2", color: "blue" },
  ]);
  const changeName = (id, name) =>
    setTodoList(
      todoList.map((item) => (item.id === id ? { ...item, name } : item))
    );
  const changeColor = (id, color) =>
    setTodoList(
      todoList.map((item) => (item.id === id ? { ...item, color } : item))
    );
```

等业务逐渐复杂，我们可能会拆分一些模块的组件，效果看起来不错，父子组件的实现都不算复杂，各司其职

```
  <NameComponent item={item} changeName={changeName}  />
  <ColorComponent item={item} changeColor={changeColor}  />
```

随着业务进一步复杂，NameComponent、ColorComponent 也需要拆分组件了。这个时候透传 state 和 props 的弊端逐渐显现，组件之间的关系就需要小心斟酌，一个不小心就会让整个数据链断掉

1. 在看了 Formily 和 wagmi 的使用后，稍微获取到了点灵感，可以用 contextProvider + hook 解决透传的问题
   上述的例子，我们可以这么做
   将 hook 中的数据结构与方法，通过 context Provide 注入到子组件里，就避免了无限层透传的问题，虽然实现上饶了一步，但使用起来会很方便

```
  // app.js
  const { Provider } = useTodoList();
  return (
    <div>
      <Provider>
        <Test></Test>
      </Provider>
    </div>

  // useTodoList.js
  export const todoListContext = createContext({
    todoList: [],
    setTodoList: () => {},
  });

  export const useTodoList = () => {
    const [todoList, setTodoList] = useState([
      { name: "1", color: "red" },
      { name: "2", color: "blue" },
    ]);
    const Provider = (props) => {
      return (
        <todoListContext.Provider value={{ todoList, setTodoList }}>
          {props.children}
        </todoListContext.Provider>
      );
    };
    return { Provider };
  };
```

2. 将数据放到 Redux 中（很麻烦）
3. 将数据放到 Mobx 中

### 非受控组件

也解决不了套娃的问题，所以也不是很好使，还是推荐用 hook