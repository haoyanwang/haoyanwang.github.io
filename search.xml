<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TCP/IP读书笔记</title>
    <url>/2022/03/12/TCP-IP%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="TCP-IP读书笔记"><a href="#TCP-IP读书笔记" class="headerlink" title="TCP/IP读书笔记"></a>TCP/IP读书笔记</h1><p>从小学开始就鼓捣电脑，很早就听说了类似ip、mac地址，VLAN,WLAN,猫，子网掩码，DNS地址等技术名词。<br>上学以后也学习了计算机网络，听说了类似OSI七层模型，TCP、UDP等概念。<br>工作以后也接触到了更多的网络知识，但一直是知其然不知其所以然，缺乏比较系统的学习，所以今天就记录一下学习的过程。</p>
<h2 id="网络规则"><a href="#网络规则" class="headerlink" title="网络规则"></a>网络规则</h2><p>二进制数字到底经过了那些步骤，最后构成了网络世界？</p>
<h3 id="OSI七层模型"><a href="#OSI七层模型" class="headerlink" title="OSI七层模型"></a>OSI七层模型</h3><p>根据主要负责的功能不同，我们将通信过程分为7层，自下而上分别为</p>
<ul>
<li>物理层（数字信号）</li>
<li>数据链路层（设备之间传输的数据帧，代表名词：以太网）</li>
<li>网络层（地址管理和路由选择，代表名词：IP协议）</li>
<li>传输层（负责节点之间的数据传递，代表名词：TCP，UDP）</li>
<li>会话层</li>
<li>表示层</li>
<li>应用层<br>在TCP/IP五层模型中<br>会话层、表示层和应用层可统称应用层（代表名词：HTTP，HTTPS，FTP，DNS）</li>
</ul>
<p>TCP/IP协议其实代表的是一组协议，不仅仅代表传输层和网络层的TCP和IP协议，还包含了其他的协议，例如HTTP，TELNET，ARP等重要协议</p>
<h3 id="物理层，数据链路层"><a href="#物理层，数据链路层" class="headerlink" title="物理层，数据链路层"></a>物理层，数据链路层</h3><p>TCP/IP中没有严格规定该层，只要求能给上层（网络层）提供一个访问接口，以太网是最常见的形式</p>
<h4 id="以太网帧"><a href="#以太网帧" class="headerlink" title="以太网帧"></a>以太网帧</h4><p>数据链路层会将二进制数封装为以太网帧，以便上层协议使用<br>以太网帧格式：</p>
<ul>
<li>目的地址、源地址（解释了从哪里来，到哪里去，分别为48位的MAC地址）</li>
<li>类型（以太网帧的类型，有数据信号和ARP握手信号）</li>
<li>数据类型</li>
<li>CRC校验（确认是否被破坏）</li>
</ul>
<h4 id="MAC地址（Media-Access-Control媒体访问控制）"><a href="#MAC地址（Media-Access-Control媒体访问控制）" class="headerlink" title="MAC地址（Media Access Control媒体访问控制）"></a>MAC地址（Media Access Control媒体访问控制）</h4><p>网卡、交换机和路由器的每个端口有一个独一无二的MAC地址，为48位二进制数，通常表示为12位16进制数</p>
<h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>在网络层中，主机之间的信息传递通过IP来进行，但是对于一台主机而言，底层的硬件和IP并没有直接的关系，也就是说，当数据包到达目标机器底层时，硬件并不知道这个数据包是否属于自己<br>那么底层硬件如何判别呢？答案是：MAC地址（硬件只知道MAC地址），一台主机会通过ARP协议来了解整个以太网络<br>一台主机连接到以太网以后会发生以下事情：</p>
<ol>
<li>主机a发送一种类型为ARP的以太网帧。这个帧携带了a的MAC地址，IP地址以及目的地b的IP地址，并将目的地的MAC地址写为00000000，并发给以太网中所有的主机</li>
<li>当以太网中的主机收到后，会查看自己的IP地址是否与目标地IP一致，如果一致，就将自己的MAC地址返回给a。这样a与b就互相知道了对方的IP地址与MAC地址</li>
<li>每台主机就可以有一个地址映射表，可以不用发送ARP就可以直接进行IP通信。并且定期清楚掉不需要的数据，这样做可以让任何主机随时接入和退出以太网<br>这样，在同一个局域网内的寻址问题就解决了，那么跨局域网的寻址是如何进行的？</li>
</ol>
<h3 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h3><p>俗称IP层。IP是一个不可靠的，无连接协议，接受来自传输层的数据，将具有目的地址的分组封装后，通过路由发送给下层。IP负责分配地址并将数据以IP包的形式传送到正确的目的地</p>
<h4 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h4><h5 id="IPv4"><a href="#IPv4" class="headerlink" title="IPv4"></a>IPv4</h5><p>IPv4地址是一个32位二进制数，用4段8位二进制数分开。<br>其中可以分为两部分：网络号和主机号<br>网络号表示ip属于互联网的哪一个网络<br>主机号表示ip属于该网络中的哪一台主机<br>根据网络号和主机号的长度以及用途，ip地址可分为A，B，C，D，E五类地址<br>A类IP：0.0.0.0<del>127.255.255.255（后24位为主机地址）（126个A类网络，可连接1677214台主机）（默认掩码255.0.0.0/8）<br>B类IP：128.0.0.0</del>191.255.255.255（后16位为主机地址）（大约16000个B类网络，可连接65534台主机）（默认掩码255.255.0.0/16）<br>C类IP：192.0.0.0<del>223.255.255.255（后8位为主机地址）（每个C类主机可连接254台主机）（默认掩码255.255.255.0/24）<br>D类IP：224.0.0.0</del>239.255.255.255（组播地址）<br>E类IP：240.0.0.0~255.255.255.255（扩展和实验开发与研究）<br>其中根据用途和安全性的不同，又可以分为公网地址和私网地址</p>
<p>为了减少ip地址的浪费，所以使用子网掩码来将一个网络划分为多个子网<br>子网掩码（是一个32位二进制数，屏蔽ip地址的一部分用来区分网络地址和主机地址）<br>子网掩码由1和0组成，且1和0必须分别连续，例如：11111111 11111111 11111111 11100000，左边是网络位用1表示，右边是主机位用0表示<br>通过子网掩码，才能表明一台主机所在的子网与其他子网的关系，使网络正常工作，以免造成ip地址的浪费</p>
<p>如何用子网掩码得到网络号/主机号：<br>将ip与子网掩码化为二进制，做与运算得到网络号<br>将子网掩码取反后，做与运算得到主机号<br>举例说明：<br>假设ip地址为：192.168.127.101<br>子网掩码为：255.255.255.192<br>分别转二进制后做与运算，再转为十进制得到：192.168.127.64，这便是网络号<br>子网掩码转二进制取反后做与运算，再转十进制得到：100101，十进制为37，这便是主机号<br>网络号不变，主机号全取1，便是广播地址，即192.168.127.127<br>主机号为6位二进制数，所以能容纳的主机数量为：2的6次方-2=62（去除网络号和广播地址），能容纳的主机数量为62个（实际上还要再减去一个网关的地址）</p>
<p>VLSM（Variable Length Subnetwork Mask，可变长子网掩码）<br>指一个网络可以用多个掩码进行配置，从主机号的部分借位作为网络号（A类有24位可借，B类有16位可借，C类有8位可借），可以更方便的将一个网络划分为多个子网<br>例如：你被分配了一个C类地址，网络号为192.168.10.0,而你现在需要将其划分为三个子网,其中一个子网有100台主机,其余的两个子网有50台主机<br>这个时候VLSM就派上了用场</p>
<p>CIDR（Classless Inter-Domain Routing，无类别域间路由选择，也称超网）<br>和VLSM刚好相反，从网络号中借位给主机号，将IP网络地址空间看成是一个整体，并划分成连续的地址块。然后，采用分块的方法进行分配<br>CIDR可以限制路由器中的路由表增大，减少路由通告<br>参考阅读：<br><a href="https://blog.csdn.net/weixin_34080951/article/details/92511829">子网掩码快速算法及可变长掩码</a></p>
<h5 id="NAT（Network-Address-Translation网络地址转换）"><a href="#NAT（Network-Address-Translation网络地址转换）" class="headerlink" title="NAT（Network Address Translation网络地址转换）"></a>NAT（Network Address Translation网络地址转换）</h5><p>目的：为了节省IPv4地址<br>NAT有三种机制：</p>
<ul>
<li>静态NAT（虚拟地址与公网地址1对1映射，无法解决ip地址紧缺对问题）</li>
<li>动态地址NAT（内部ip临时分配外部ip，不需要长期连接到外网上）</li>
<li>网络地址端口转换NAPT（将内部地址分配到外部地址不同的TCP端口上）（从外部看，所有信息来源与同一个ip，但又能精确识别来自那台主机）</li>
</ul>
<h4 id="IP包的转发规则"><a href="#IP包的转发规则" class="headerlink" title="IP包的转发规则"></a>IP包的转发规则</h4><ol>
<li>IP包会根据目的地进行转发，如果没有明确的下一站的地址，就会按照缺省网关的路径前进（大部分为以太网的出口路由器）</li>
<li>当IP包到达出口路由器，路由器会根据自身的路由表，将IP包通过合适的端口送出去</li>
</ol>
<h4 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h4><p>路由协议分为两种</p>
<ul>
<li>静态路由（手动填写，只有缺省路由表和小型网络会使用，不灵活，维护成本高）</li>
<li>动态路由（路由和相邻的路由互相通信，交换信息，最终获得全网的路由信息）<br>动态路由协议又分为</li>
<li>内部路由协议（距离矢量算法，链路状态算法）</li>
<li>外部路由协议（BGP协议是唯一的外部路由协议）<br>内外是一个相对的概念，路由协议相对的是自治域（AS）来说的<br>自治域就是一张拥有独立网络调控功能，统一策略的IP网络（例如家庭企业接入网络，教育、金融专用网等等）<br>且一个自治与有且只有一个管理者（各大运营商），但一个管理者可以拥有多个自治域</li>
</ul>
<p>内部路由协议中的距离矢量算法和链路状态算区别是什么？</p>
<ul>
<li><p>距离矢量路由协议<br>交换的是相邻路由的路由表，路由器不知道完整的拓扑结构，链路发生变化后，路由条目维护成本较大，所以不适合大型网络</p>
<h4 id="IGP（内部路由协议）"><a href="#IGP（内部路由协议）" class="headerlink" title="IGP（内部路由协议）"></a>IGP（内部路由协议）</h4><h5 id="RIP2协议"><a href="#RIP2协议" class="headerlink" title="RIP2协议"></a>RIP2协议</h5><p>RIP2是路径成本算法最简单的一个，仅仅根据路由需要经过的跳转数进行判断。如果有2条路线，一条经过5个路由器，一条经过10个路由器，RIP2算法就会选择第一条<br>因为简单，所以不会考虑阻塞程度等因素，所以适合于较小的网络结构</p>
</li>
<li><p>链路状态路由协议<br>路由交换链路状态，交换完成后，路由器会拥有全网的拓扑结构，再根据算法计算出路径。采用增量更新，链路发生变化，只需要告诉有关路由器。</p>
<h5 id="IS-IS协议（主流协议）"><a href="#IS-IS协议（主流协议）" class="headerlink" title="IS-IS协议（主流协议）"></a>IS-IS协议（主流协议）</h5><p>收集网络内的节点和链路状态，构建出一个链路数据库，根据算法计算出最优路径（优先AS域内的跳转）<br>IS-IS分层：<br>L1普通区域，是区域内路由，只保留本区域的路由（村民）<br>L12，负责区域间的数据交换，通常位于区域边界上（村长）<br>L2骨干区域，是区域间路由，保存骨干区的路由（乡长）<br>工作原理：</p>
</li>
</ul>
<ol>
<li>建立连接关系（通过L12，L2互相通信）</li>
<li>链路状态信息泛洪（将信息互相发送给邻居，达到链路状态数据库的一致性）<br>计算路径：<br>狄杰斯特拉算法（广度优先计算最短路径）</li>
</ol>
<h5 id="OSPF（Open-Shortest-Path-First，开放式最短路径优先协议）"><a href="#OSPF（Open-Shortest-Path-First，开放式最短路径优先协议）" class="headerlink" title="OSPF（Open Shortest Path First，开放式最短路径优先协议）"></a>OSPF（Open Shortest Path First，开放式最短路径优先协议）</h5><p>与IS-IS类似</p>
<h4 id="EGP（外部路由协议）"><a href="#EGP（外部路由协议）" class="headerlink" title="EGP（外部路由协议）"></a>EGP（外部路由协议）</h4><h5 id="BGP（Border-Gateway-Protocol，边界网关协议）"><a href="#BGP（Border-Gateway-Protocol，边界网关协议）" class="headerlink" title="BGP（Border Gateway Protocol，边界网关协议）"></a>BGP（Border Gateway Protocol，边界网关协议）</h5><p>外部路由协议的层次更高，适用于不同AS之间的路由传播，没有发现和计算路由的功能，而是着重于控制路由传播和选择更好的路由。<br>外部协议是基于内部协议之上的，进行BGP传播的路由器首先要确保IGP可达。BGP需要人工配置，并建立在TCP协议之上，端口号为179</p>
<h3 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h3><p>TCP和UDP协议属于该层</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP为了保证可靠性，采用了数据分块，维护计时器，发送确认，校验和计算，丢弃重复数据和流量控制等方式<br>TCP是一种面向字节流的服务，它并不关心自己传送的是二进制、ASCII码还是其他的什么，连接双方的高层协议负责对数据进行解释</p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p>UDP擅长查询-应答服务，交换的信息量少</p>
<h3 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h3><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><p>HTTP1.1相较于HTTP1.0：</p>
<ul>
<li>更多可供选择的缓存策略</li>
<li>带宽优化及网络连接的使用，请求头引入了range头域，它允许只请求资源的某个部分</li>
<li>Host头处理，应对一个IP上存在的多台虚拟主机</li>
<li>HTTP长链接，一个TCP连接传送多个HTTP请求，keep-alive<br>采用管道连接：<br>所谓请求管道，就是在HTTP响应到达之前，可以将多条请求放入队列，当第一条HTTP请求通过网络流向服务器时，第二条和第三条请求也可以开始发送了。但是服务端必须按照与请求相同的顺序回送HTTP响应<br>这也就意味着，如果一个响应返回发生了延迟，那么其后续的响应都会被延迟，直到队头的响应送达。这就是所谓的HTTP队头阻塞<br>HTTP队头阻塞的问题在HTTP/2中得到了有效的解决</li>
</ul>
<p>SPDY（speedy的昵音，意思是更快，Google开发的基于TCP的应用层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验）：</p>
<ul>
<li>多路复用<br>一个域只需要一次tcp连接，一个 SPDY 连接内可以有无限个并行请求，即允许多个并发HTTP 请求共用一个TCP会话</li>
<li>请求优先级<br>它会选择性的先传输 CSS 这样更重要的资源，然后再传输网站图标之类不太重要的资源，可以避免让非关键资源占用网络通道的问题，提升 TCP 的性能</li>
<li>header压缩<br>舍弃掉了不必要的头信息，经过压缩之后可以节省多余数据传输所带来的等待时间和带宽</li>
<li>HTTPS</li>
<li>服务器推送<br>服务端能通过 push 的方式将客户端需要的内容预先推送过去</li>
</ul>
<p>HTTP2.0（SPDY升级版）：</p>
<ul>
<li>支持HTTP明文传输，而SPDY强制使用HTTPS</li>
<li>HTTP/2 消息头的压缩算法采用 HPACK，而非 SPDY 采用的 DELEFT</li>
<li>HTTP1.x是基于文本传送，HTTP2是基于二进制传送<br>应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层<br>HTTP/2引入了帧、消息和数据流等概念，把HTTP消息分解为互不依赖的帧，然后乱序发送，最后再在另一端把它们重新组合起来，这样HTTP/2就解决了HTTP的队头阻塞<br>但TCP传输过程中会把数据拆分为一个个按照顺序排列的数据包，接收端再按照顺序将这些数据包组合成原始数据，如果其中的某一个数据包没有按照顺序到达，就会阻塞后续请求，就发生了TCP队头阻塞<br>HTTP/1.1规定一个域名可以有6个TCP连接，而HTTP/2中，同一个域名只是用一个TCP连接，所以，在HTTP/2中，TCP队头阻塞造成的影响会更大</li>
</ul>
<p>RTT（Round Trip Time，网络延迟）：<br>是指一个请求从客户端浏览器发送一个请求数据包到服务器，再从服务器得到响应数据包的这段时间。RTT 是反映网络性能的一个重要指标<br>一个纯的HTTPS需要3-4个RTT（TCP握手+TLS握手）</p>
<p>HTTP3.0<br>上面提到的这些问题的根本原因都是因为HTTP/2是基于TPC实现导致的，而TCP协议自身的升级又是很难实现的（因为很多中间设备比较陈旧，更新换代成本巨大，这就导致TCP协议升级或者采用新的协议基本无法实现。）<br>所以google搞了一个基于UDP协议的QUIC（Quick UDP Internet Connections）协议，HTTP over QUIC，重命名为HTTP/3<br>QUIC协议特点：</p>
<ul>
<li>基于UDP</li>
<li>可靠性<br>虽然UDP是不可靠传输协议，但是QUIC在UDP的基础上做了些改造，使得他提供了和TCP类似的可靠性。它提供了数据包重传、拥塞控制、调整传输节奏以及其他一些TCP中存在的特性</li>
<li>实现了无序、并发字节流<br>单个数据流的传输是按序的，但是多个数据流中接收方收到的顺序可能与发送方的发送顺序不同</li>
<li>快速握手<br>QUIC提供0-RTT和1-RTT的连接建立<br>QUIC 连接的建立整体流程大致为：<br>初次握手：</li>
</ul>
<ol>
<li>客户端会向服务端发送一个打招呼信息(CHLO)</li>
<li>因为是初次建立，所以，服务端会返回一个拒绝消息（REJ），表明握手未建立或者密钥已过期，这个拒绝消息中还会包含更多的信息（配置参数）</li>
<li>在客户端接收到拒绝消息（REJ）之后，客户端会进行数据解析，签名验证等操作，之后会将必要的配置缓存下来</li>
<li>客户端会打包一个消息包发送给服务端，为了减少RTT，客户端并不会等到服务器的响应，而是立刻会进行数据传输</li>
<li>为了保证数据的安全性，客户端会自己的密钥和服务器返回的公钥进行运算，得到一个初始密钥（initial keys）将想要传输的信息进行加密，然后把他们安全的传输给服务端了</li>
<li>另外一面，接收到Complete CHLO请求的服务器，通过运算，服务端就能得到一份和客户端一模一样的初始密钥（initial keys）<br>所以，从开始建立连接一直到数据传送，只消耗了初始连接连接建立的 1 RTT<br>最终（与重复）握手：<br>当下一次要重新创建连接的时候，客户端会从缓存中取出自己之前缓存下来的服务器的公钥，并重新创建一个密钥，重新生成一个初始密钥，再使用这个初始密钥对想要传输的数据进行加密，向服务器发送一个Complete CHLO 请求即可。这样就达到了0 RTT的数据传输<br>所以，如果是有缓存的长期公钥，那么数据传输就会直接进行，准备时间是0 RTT</li>
</ol>
<ul>
<li>多路复用<br>QUIC的单个数据流可以保证有序交付，但多个数据流之间可能乱序。这意味着单个数据流的传输是按序的，但是多个数据流中接收方收到的顺序可能与发送方的发送顺序不同（猜测可能是通过sessionId进行区分？）</li>
<li>连接迁移<br>对于TCP连接的识别，需要通过服务器和客户端过双方的ip和端口四个参数进行的。在网络切换的场景中，比如手机切换网络，那么自身的ip就会发生变化。这就导致之前的TCP连接就会失效，就需要重新建立<br>QUIC协议使用特有的UUID来标记每一次连接，在网络环境发生变化的时候，只要UUID不变，就能不需要握手，继续传输数据</li>
<li>可靠性保证<br>诸如流量控制、数据重传、拥塞控制等可靠性保证</li>
</ul>
<p>参考阅读：<br><a href="https://www.cnblogs.com/keva/p/spdy-protocol.html">SPDY协议</a><br><a href="https://www.zhihu.com/question/34074946/answer/108588042">HTTP/2</a><br><a href="https://my.oschina.net/editorial-story/blog/3031721">HTTP协议这些年经历了些啥</a><br><a href="https://mp.weixin.qq.com/s/-sD504t5Ebm0Ubwalos8DA">HTTP3到底是个什么鬼？</a></p>
<h3 id="安全机制"><a href="#安全机制" class="headerlink" title="安全机制"></a>安全机制</h3><h4 id="IP层的安全机制"><a href="#IP层的安全机制" class="headerlink" title="IP层的安全机制"></a>IP层的安全机制</h4><p>针对IP报文进行加密，有认证头（Authentication Header）以及封装安全有效负荷（Encapsulating Security Payload，ESP）<br>优点：底层加密，上层应用无感知<br>缺点：统一加密，性能下降<br>应用：IP VPN（Virtual Private Network）（在公网上封装加密数据通信隧道）</p>
<h4 id="传输层的安全机制"><a href="#传输层的安全机制" class="headerlink" title="传输层的安全机制"></a>传输层的安全机制</h4><p>TCP：通信加密和安全认证<br>优点：基于进程和进程之间的加密<br>应用：BSD Sockets，传输层接口（TLI）<br>UDP：较难建立安全机制</p>
<h4 id="应用层的安全机制"><a href="#应用层的安全机制" class="headerlink" title="应用层的安全机制"></a>应用层的安全机制</h4><p>IP层与传输层的安全机制之间所有的消息都要加密，无法区分不同文件的安全性要求，所以必须借助应用层的安全机制<br>应用：HTTPS</p>
<h5 id="HTTPS（HTTP-TLS）"><a href="#HTTPS（HTTP-TLS）" class="headerlink" title="HTTPS（HTTP+TLS）"></a>HTTPS（HTTP+TLS）</h5><p>HTTPS协议通过数据加密、校验数据完整性和身份认证三种机制来保障安全<br>HTTPS协议混合对称密钥加密和非对称加密机制<br>对称加密：<br>传输双方共享相同的秘钥，通用相同的秘钥实现数据的加密和解密过程（同一把锁，传输双方拥有同样的钥匙）<br>优点：算法公开、计算量小、加密速度快、加密效率高<br>缺点：在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了<br>非对称加密：<br>非对称加密算法需要两个密钥，公钥与私钥是一对，公钥匙可以公开的，私钥需要保密，如果用公钥对数据进行加密，只有用对应的私钥才能解密<br>优点：它的安全性可靠性极高，在非对称体系下可以实现签名认证和加密传输功能<br>缺点：加密代价高<br>签名认证（解决身份认证的问题，确保内容一定是服务器加密发送的）：<br>用私钥加密的密文，只能被公钥解密，如果能解开，就能确保消息是由私钥拥有者加密的，否则消息是被其他人加密的<br>将自己的认证通过私钥加密后，附加在加密正文后，就完成了签名认证的过程</p>
<p>加密的演变过程：</p>
<ul>
<li>假设Alice和Bob之间要进行通信，为了安全必须要达到：即使被中间人拦截到了，也无法得知消息的内容</li>
<li>使用对称加密算法可以解决这个问题，消息是加密的，中间人无法解密，就无法得知消息的内容</li>
<li>但加密算法的细节是无法通用的，如果在http中，大家都使用同样的加密算法，那等同于没有加密</li>
<li>于是Web服务器与每个客户端使用不同的对称加密算法（随机数），客户端也不可能保存所有网站的算法，所以通过协商，服务器在通信时告诉客户端该使用哪种对称加密算法</li>
<li>但是协商的过程也不是安全的，还是可能会被中间人拦截</li>
<li>使用非对称加密+数字证书来确保协商过程的安全，客户端将CA证书的公钥保存起来，利用数字签名以信任证书</li>
<li>客户端信任证书，证书信任服务端，所以客户端就信任服务端，就可以根据协商加密建立起安全的对称加密通信</li>
<li>但是，万一中间人也注册了证书，并在客户端与证书之间拦截替换了协商内容（客户端收到了证书认证的内容，但这个内容不是这次想要的）</li>
<li>证书会告诉客户端证书编号，客户端本地验证证书编号，来判断可靠性</li>
</ul>
<p>TLS握手过程：</p>
<ul>
<li>客户端发送ClientHello，以明文传输，包括：客户端支持的TLS版本号，安全套件（cipher suit）（密钥交换算法，签名算法/验签算法，摘要算法，对称加密算法），随机数A，压缩算法，重用握手等session id等</li>
<li>服务端返回SeverHello，生成随机数B，确认并允许握手</li>
<li>客户端证书校验，从证书中获取服务器的公钥，生成随机字符串（premaster secret），并用服务器公钥进行加密，发送给服务器</li>
<li>服务器收到后，用私钥解密premaster secret，客户端与服务器使用相同的算法，随机数AB，premaster secret生成用于对称加密的规则</li>
<li>使用对称加密互相发送finished信号</li>
</ul>
<h4 id="常见FQ工具的加密原理（具体源码细节日后再研究…）"><a href="#常见FQ工具的加密原理（具体源码细节日后再研究…）" class="headerlink" title="常见FQ工具的加密原理（具体源码细节日后再研究…）"></a>常见FQ工具的加密原理（具体源码细节日后再研究…）</h4><h5 id="shadowsocks"><a href="#shadowsocks" class="headerlink" title="shadowsocks"></a>shadowsocks</h5><p>shadowsocks在本地（ss local）建立socket5（位于传输层和会话层之间的通信协议）加密服务，发送给ss server后请求内容</p>
<h5 id="V2Ray，Trojan"><a href="#V2Ray，Trojan" class="headerlink" title="V2Ray，Trojan"></a>V2Ray，Trojan</h5><p>WebSocket+TLS，模拟HTTPS</p>
<p>（依稀记得前同事说他挖了V2Ray的bug，因为模拟浏览器数据不够严谨，所以能被识别。其他的方式还有解同步暴力拆Q的方式（不推荐），自己日后再慢慢研究<br>参考阅读：</p>
<ul>
<li><a href="https://www.idleleo.com/10/4766.html">V2Ray、Trojan等主流工具安全吗？</a></li>
<li><a href="https://www.idleleo.com/05/2071.html">V2Ray / SSR 传输协议哪个好? (各种协议对比)</a></li>
<li><a href="https://wonderkun.cc/2020/02/18/shadowsocks%E7%9A%84%E9%80%9A%E4%BF%A1%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95%E5%88%86%E6%9E%90/">shadowsocks的通信原理以及攻击方法分析</a></li>
</ul>
<h3 id="生活中的网络"><a href="#生活中的网络" class="headerlink" title="生活中的网络"></a>生活中的网络</h3><p>从小学开始就接触电脑玩游戏，很多概念都耳熟能详，例如：拨号，宽带，猫，光纤，路由器，交换机，AP，DHCP，VLAN等等，但对于具体知识都不清楚，所以学习一下这些知识<br>网线:<br>UTP(Unshielded Twisted Pair，非屏蔽双绞线)+RJ45水晶头<br>双绞线互相绞合用于抗电磁干扰（不知道我的HDMI转Type-C是不是因为电磁干扰，天天灭屏）<br>1对2对双绞线用于电话线，4对用于以太网，25对或50对大对数电缆用于语音或数据业务的接入<br>以太网线共有5类4个线对，一共8根线，对应RJ45水晶头的8个凹槽</p>
<p>拨号上网：<br>通过猫和一根电话线，向服务商申请上网账号后，通过拨号的方式接入到互联网中</p>
<p>光纤（光导纤维）：<br>利用光的全反射来传递信息</p>
<p>猫（Modem，调制解调器）：<br>传统意义的猫：可以将电话线中的模拟信号与数字信号互相转换<br>光猫：将光信号转为数字信号（自动拨号）</p>
<p>ADSL（Asymmetric Digital Subscriber Line，非对称数字用户线路）：<br>是宽带接入技术中的一种，所谓非对称主要体现在上行速率和下行速率的非对称性上<br>特点：</p>
<ul>
<li>提供上、下行不对称的传输带宽，下载速度快，上传速度较慢</li>
<li>上网、打电话互不干扰（遥想当年一打电话就断网）</li>
</ul>
<p>DHCP（动态主机配置协议）：<br>DHCP是基于UDP的应用层协议<br>服务器分配IP地址、子网掩码和DNS等信息</p>
<p>VLAN（Virtual Local Area Network，虚拟局域网）：<br>将局域网从逻辑上分为一个个网段。如果所有的局域网处于同一个网段，在实际通信中，将会发生ARP泛洪，浪费了带宽也增加了CPU的负担。<br>所以通过对交换机对端口进行分组，将物理的LAN在逻辑上划分为多个广播域（VLAN）<br>不同VLAN之间无法直接通信，需要通过路由器或三层交换机<br>VLAN种类：</p>
<ul>
<li>基于端口的静态VLAN</li>
<li>基于IP（子网）的动态VLAN</li>
</ul>
<p>交换机：<br>交换机（二层交换机）属于数据链路层即根据MAC地址进行数据转发<br>三层交换机，是具有部分路由器功能的交换机，属于网络层，目的是为了加快不同VLAN之间的通信（二层交换机做不到，路由器太慢）</p>
<p>无线AP（Access Point）：<br>是无线路由器等设备的统称，是无线局域网的一种典型应用，在无线网络中，AP就相当于有线网络的集线器，用来中继和桥接无线信号</p>
<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<script >
var gitalk = new Gitalk({
  clientID: '690f7443a587c05ba6f5',
  clientSecret: '5702fe23820d4464abfd4e2f9a736da2565ae3c9',
  repo: 'haoyanwang.github.io',
  owner: 'haoyanwang',
  admin: ['haoyanwang'],
  id: md5(location.pathname),  
  distractionFreeMode: false,
});
gitalk.render('gitalk-container')
</script>


]]></content>
  </entry>
  <entry>
    <title>电子邮件</title>
    <url>/2021/02/23/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="电子邮件"><a href="#电子邮件" class="headerlink" title="电子邮件"></a>电子邮件</h1><p>最近在发邮件服务上遇到点问题，所以深入研究一下电子邮件的原理细节（因为自己个人不经常使用，总有一种email很久远的感觉）</p>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="邮件"><a href="#邮件" class="headerlink" title="邮件"></a>邮件</h3><p>邮件是一种消息的格式，由信封、首部和正文组成。</p>
<ul>
<li>信封上最重要的是收信人的地址。邮件服务器用这个地址将邮件发送到收信人所在的邮件服务器上。</li>
<li>首部是由用户代理或邮件服务器添加的一些信息。包括Received、Message-ID、From、Data、Reply-To、X-Phone、X-Mailer、To和Subject等字段。</li>
<li>正文是是发送用户发给接收用户报文的内容。</li>
</ul>
<h3 id="用户代理"><a href="#用户代理" class="headerlink" title="用户代理"></a>用户代理</h3><p>用户代理UA（User Agent）是用户与电子邮件系统的交互接口，一般来说它就是我们PC机上的一个程序。Windows上常见的用户代理是Foxmail和Outlook客户端。<br>用户代理提供一个好的用户界面，它提取用户在其界面填写的各项信息，生成一封符合SMTP等邮件标准的邮件，然后采用SMTP协议将邮件发送到发送端邮件服务器。</p>
<h3 id="邮件的收发过程"><a href="#邮件的收发过程" class="headerlink" title="邮件的收发过程"></a>邮件的收发过程</h3><p>一般情况下，一封邮件的发送和接收过程如下。</p>
<ol>
<li>发信人在用户代理里编辑邮件，包括填写发信人邮箱、收信人邮箱和邮件标题等等。</li>
<li>用户代理提取发信人编辑的信息，生成一封符合邮件格式标准的邮件。</li>
<li>用户代理用SMTP将邮件发送到发送端邮件服务器（即发信人邮箱所对应的邮件服务器）。</li>
<li>发送端邮件服务器用SMTP将邮件发送到接收端邮件服务器（即收信人邮箱所对应的邮件服务器）。</li>
<li>收信人调用用户代理。用户代理用POP3协议从接收端邮件服务器取回邮件。</li>
<li>用户代理解析收到的邮件，以适当的形式呈现在收信人面前。</li>
</ol>
<h2 id="电子邮件相关协议"><a href="#电子邮件相关协议" class="headerlink" title="电子邮件相关协议"></a>电子邮件相关协议</h2><h3 id="SMTP协议（Simple-Mail-Transfer-Protocal）"><a href="#SMTP协议（Simple-Mail-Transfer-Protocal）" class="headerlink" title="SMTP协议（Simple Mail Transfer Protocal）"></a>SMTP协议（Simple Mail Transfer Protocal）</h3><p>SMTP协议是用于发送方的邮件服务器发送报文到接收方邮件服务器。它是一种推协议，通常它工作在两种情况下：一是邮件从客户机传输到服务器；二是从某一个服务器传输到另一个服务器。<br>SMTP协议基于 <a href="https://haoyanwang.github.io/2020/12/20/TCP-IP%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/#TCP">TCP协议</a> ，监听25号端口。<br>PC通过邮件客户端使用SMTP协议将邮件，推送到邮件服务器上<br>邮件服务器再通过SMTP协议，将邮件送到对方的邮件服务器上，等到对方上网的时候，就可以收到你所寄的信<br>（个人不是很理解为什么不使用HTTP协议推送呢，也许因为当时HTTP协议还不够成熟？也有说法是HTTP是一种拉取协议，这里需要的是一种推送协议）</p>
<p><img src="https://img-blog.csdn.net/20180720142251413?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdW1pYW9jbg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="avatar"> </p>
<p>一个具体的SMTP通信（如发送端邮件服务器与接收端服务器的通信）的过程如下：</p>
<ol>
<li>发送端邮件服务器（以下简称客户端）与接收端邮件服务器（以下简称服务器）的25号端口建立TCP连接。</li>
<li>客户端向服务器发送各种命令，来请求各种服务（如认证、指定发送人和接收人）。</li>
<li>服务器解析用户的命令，做出相应动作并返回给客户端一个响应。</li>
<li>2和3交替进行，直到所有邮件都发送完或两者的连接被意外中断。<br>具体例子、命令以及响应见参考链接</li>
</ol>
<p>SMTP的优缺点</p>
<ul>
<li>邮件内容受限<br>因为SMTP协议采用ASCII码进行编码<br>二进制文件、声音和动画等其他复杂内容，实现起来将十分困难，所以RFC标准就扩展了新的电子邮件标准，MIME（Multipurpose Internet Mail Extensions，多用途互联网邮件扩展类型）<br>MIME最早应用于电子邮件系统，但后来也应用到浏览器。服务器会将它们发送的多媒体数据的类型告诉浏览器</li>
<li>命令过于简单，没提供认证等功能<br>ESMTP是添加了用户认证功的SMTP</li>
</ul>
<h3 id="MIME协议"><a href="#MIME协议" class="headerlink" title="MIME协议"></a>MIME协议</h3><p>MIME协议通过改进邮件头和邮件体，试图在不改变SMTP协议和邮件格式标准的基础上，使得邮件可以传输任何二进制文件。<br>在邮件头内指定MIME-Version、Content-Type和Content-Transfer-Encoding等字段</p>
<h4 id="Content-Type（内容类型域）"><a href="#Content-Type（内容类型域）" class="headerlink" title="Content-Type（内容类型域）"></a>Content-Type（内容类型域）</h4><p>由主类型/子类型组成，来指定邮件体的类型，常见的有text/plain（纯文本）和text/html（html邮件）</p>
<h4 id="Content-Transfer-Encoding（传送编码域）"><a href="#Content-Transfer-Encoding（传送编码域）" class="headerlink" title="Content-Transfer-Encoding（传送编码域）"></a>Content-Transfer-Encoding（传送编码域）</h4><p>共有Base64、Quoted-printable，7bit，8bit和Binary几种类型</p>
<h3 id="编码方式"><a href="#编码方式" class="headerlink" title="编码方式"></a>编码方式</h3><h4 id="7位ASCII码"><a href="#7位ASCII码" class="headerlink" title="7位ASCII码"></a>7位ASCII码</h4><p>由7位二进制组成，可表示128个字符，其中包括95个可打印字符和33个控制字符<br>其中48～57为0到9十个阿拉伯数字，65～90为26个大写英文字母，97～122号为26个小写英文字母，其余为一些标点符号、运算符号等。</p>
<h4 id="Quoted-printable编码"><a href="#Quoted-printable编码" class="headerlink" title="Quoted-printable编码"></a>Quoted-printable编码</h4><p>Quoted-printable编码用一些可打印常用字符，表示一个字节（8位）中所有非打印字符方法<br>33个不可打印字符，可编码为3个字符：一个等号”=”后跟随两个十六进制数字(0–9或A–F)表示该字节的数值.例如，ASCII码换页符（十进制值为12）可以表示为”=0C”<br>详细规则见<a href="http://blog.chacuo.net/494.html">参考阅读</a></p>
<p>例如：<br>If you believe that truth=beauty, then surely mathematics is the most beautiful branch of philosophy.<br>编码后结果是：<br>If you believe that truth=3Dbeauty, then surely=20=<br>mathematics is the most beautiful branch of philosophy.</p>
<h4 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h4><p>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。<br>64个可打印字符的索引，[‘A’, ‘B’, ‘C’, … ‘a’, ‘b’, ‘c’, … ‘0’, ‘1’, … ‘+’, ‘/‘]，这是标准的Base64协议规定。<br>转换步骤：</p>
<ol>
<li>将待转换的字符串每三个字节分为一组，每个字节占8bit，那么共有24个二进制位。</li>
<li>将上面的24个二进制位每6个一组，共分为4组。</li>
<li>在每组前面添加两个0，每组由6个变为8个二进制位，总共32个二进制位，即四个字节。</li>
<li>根据Base64映射表，获得对应的值<br>特点：</li>
</ol>
<ul>
<li>大多数编码都是由字符串转化成二进制的过程，而Base64的编码则是从二进制转换为字符串。与常规恰恰相反，</li>
<li>Base64编码主要用在传输、存储、表示二进制领域，不能算得上加密，只是无法直接看到明文。也可以通过打乱Base64编码来进行加密。</li>
<li>中文有多种编码（比如：utf-8、gb2312、gbk等），不同编码对应Base64编码结果都不一样。</li>
<li>上面我们已经看到了Base64就是用6位（2的6次幂就是64）表示字符，因此成为Base64。同理，Base32就是用5位，Base16就是用4位。</li>
</ul>
<p>具体例子和特殊情况见<a href="https://blog.csdn.net/wo541075754/article/details/81734770">参考阅读</a></p>
<h3 id="POP3（Post-Office-Protocol-3，邮局协议版本3）"><a href="#POP3（Post-Office-Protocol-3，邮局协议版本3）" class="headerlink" title="POP3（Post Office Protocol-3，邮局协议版本3）"></a>POP3（Post Office Protocol-3，邮局协议版本3）</h3><p>邮件客户端连接邮件服务器，并下载所有未阅读的电子邮件<br>默认端口：110<br>传输协议：TCP<br>架构结构：C/S<br>访问模式：离线访问</p>
<p>POP3有三种生命周期：</p>
<ul>
<li>确认</li>
<li>操作</li>
<li>更新</li>
</ul>
<p>参考链接：<br><a href="https://blog.csdn.net/liangxiaozhang/article/details/7841975?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control">SMTP协议分析</a><br><a href="https://liumiaocn.blog.csdn.net/article/details/81131420?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.control">使用Telnet学习SMTP协议</a><br><a href="https://wenku.baidu.com/view/0af3cfb905087632311212be.html">MIME协议详解</a><br><a href="https://blog.csdn.net/wo541075754/article/details/81734770">Base64编码详解</a><br><a href="http://blog.chacuo.net/494.html">Quoted-printable 编码介绍、编码解码转换</a></p>
<h2 id="编辑电子邮件"><a href="#编辑电子邮件" class="headerlink" title="编辑电子邮件"></a>编辑电子邮件</h2><h3 id="HTML格式的电子邮件"><a href="#HTML格式的电子邮件" class="headerlink" title="HTML格式的电子邮件"></a>HTML格式的电子邮件</h3><p>编写电子邮件模板不是一个愉快的体验，因为电子邮件客户端的解析引擎并不是常见的浏览器，会有各种兼容性问题<br>例如：</p>
<ul>
<li>需要使用Table+css的布局</li>
<li>仅仅支持内联css，不支持style标签以及引入的css</li>
<li>不支持min-width和max-width</li>
<li>不支持任何margin</li>
<li>不支持任何定位属性<br>等等一系列问题（个人感觉需要一个大手子来淘汰电子邮件的html。现在虽然有用来兼容的库，但是学习这些不同的库，了解这些问题也是需要成本的）</li>
</ul>
]]></content>
  </entry>
  <entry>
    <title>正则表达式</title>
    <url>/2022/03/20/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>正则用过就忘，只有大概的印象，总结一下，做几道题目熟练熟练</p>
<p>涉及到的概念</p>
<ul>
<li>常用js api</li>
<li>贪婪匹配</li>
<li>先行断言、后行断言</li>
<li>单词边界断言</li>
</ul>
<h2 id="常用js-api"><a href="#常用js-api" class="headerlink" title="常用js api"></a>常用js api</h2><ol>
<li>str.replace(regexp, replacement)<br>regexp可以是正则 也可以是 字面量字符串<br>replacement可以是字符串也可以是函数<br>replacement是字符串时， $ 字符具有特定的含义</li>
</ol>
<ul>
<li>$1、$2、…、$99 表示第 1 到第 99 个子表达式相匹配的文本</li>
<li>$&amp; 表示与 regexp 相匹配的子串</li>
<li>$` 表示位于匹配子串左侧的文本</li>
<li>$’ 表示位于匹配子串右侧的文本</li>
<li>$$ 表示直接量符号<br>eg.<br>“Doe, John” =&gt; “John Doe” ： replace(/(\w+)\s*, \s*(\w+)/, “$2 $1”)<br>‘“a”, “b”‘ =&gt; ‘a, b’ ： replace(/“([^”]*)”/g, “‘$1’”)<br>replacement是函数时，返回的字符串作为替换文本，参数具有特殊含义</li>
</ul>
<ol start="2">
<li>regexp.test(string)<br>字符串是否有匹配的模式，返回true or false</li>
<li>regexp.exec(string)<br>如果字符串中有匹配的值返回匹配结果数组，否则返回 null<br>匹配结果数组包括：第一项是匹配的结果，后面分别是子表达式匹配的结果<br>数组还有index、input、groups属性，这个操作还是第一次见，不过想想也合理，毕竟array底层是object</li>
<li>string.match(regexp)<br>找到字符串中的匹配值，返回一个结果数组</li>
</ol>
<h2 id="贪婪匹配"><a href="#贪婪匹配" class="headerlink" title="贪婪匹配"></a>贪婪匹配</h2><p>正则使用量词匹配时，默认趋向于更多的匹配，在量词后面加上?，则可以使用非贪婪匹配</p>
<p>量词匹配</p>
<ul>
<li>{m,n} m到n个 {m,n}?尽可能接近m个</li>
<li><ul>
<li>任意多个 *? 尽可能少</li>
</ul>
</li>
<li><ul>
<li>一个或多个 +? 尽可能少</li>
</ul>
</li>
<li>? 没有或一个 ?? 尽可能没有</li>
</ul>
<h2 id="先行断言、后行断言"><a href="#先行断言、后行断言" class="headerlink" title="先行断言、后行断言"></a>先行断言、后行断言</h2><p>(?=pattern) 零宽正向先行断言：代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配 pattern<br>eg. 对 “a regular expression” 这个字符串，要想匹配 regular 中的 re，但不能匹配 expression 中的 re，可以用 re(?=gular)，该表达式限定了 re 右边的位置，这个位置之后是 gular，但并不消耗 gular 这些字符</p>
<p>(?!pattern) 零宽负向先行断言：代表字符串中的一个位置，紧接该位置之后的字符序列不能匹配 pattern<br>eg. 对 “regex represents regular expression” 这个字符串，要想匹配除 regex 和 regular 之外的 re，可以用 re(?!g)，该表达式限定了 re 右边的位置，这个位置后面不是字符 g</p>
<p>(?&lt;=pattern) 零宽正向后行断言：代表字符串中的一个位置，紧接该位置之前的字符序列能够匹配 pattern<br>eg. 对 regex represents regular expression 这个字符串，有 4 个单词，要想匹配单词内部的 re，但不匹配单词开头的 re，可以用 (?&lt;=\w)re，单词内部的 re，在 re 前面应该是一个单词字符</p>
<p>(?&lt;!pattern) 零宽负向后行断言：代表字符串中的一个位置，紧接该位置之前的字符序列不能匹配 pattern<br>eg. 对 “regex represents regular expression” 这个字符串，要想匹配单词开头的 re，可以用 (?&lt;!\w)re。单词开头的 re，在本例中，也就是指不在单词内部的 re，即 re 前面不是单词字符。当然也可以用 \bre 来匹配</p>
<p>在匹配过程中，不占用字符，所以被称为”零宽”</p>
<h2 id="单词边界"><a href="#单词边界" class="headerlink" title="单词边界"></a>单词边界</h2><p>可以理解为：分割单词的位置，而不是字符。既一边是单词字符（\w可以匹配的，0-9 + 26个大小写字母），另一边不是<br>\b 表示单词边界<br>\B 表示非单词边界（不常用）</p>
<p>eg.<br>(\b)some(\b) (\b)word(\b)<br>在这个例子中有4处单词边界<br>且并不代表任何字符<br>且不区分左右，只要满足条件就行</p>
<p>eg.<br>隐藏手机号4-7位<br>text.replace(/\d{4}(?=\d{4}\b)/, ‘****’)</p>
<h2 id="codeWars"><a href="#codeWars" class="headerlink" title="codeWars"></a>codeWars</h2><h3 id="8-kyu（黑铁级）"><a href="#8-kyu（黑铁级）" class="headerlink" title="8 kyu（黑铁级）"></a>8 kyu（黑铁级）</h3><ol>
<li><a href="https://www.codewars.com/kata/57e1e61ba396b3727c000251/train/javascript">https://www.codewars.com/kata/57e1e61ba396b3727c000251/train/javascript</a><br> s.replace(/\d/g,’’)</li>
<li><a href="https://www.codewars.com/kata/567bf4f7ee34510f69000032/train/javascript">https://www.codewars.com/kata/567bf4f7ee34510f69000032/train/javascript</a><br> /^\d$/.test(this)</li>
<li><a href="https://www.codewars.com/kata/56a3f08aa9a6cc9b75000023/train/javascript">https://www.codewars.com/kata/56a3f08aa9a6cc9b75000023/train/javascript</a><br> /^[0-9a-z_]{4,16}$/.test(username)</li>
<li><a href="https://www.codewars.com/kata/57a37f3cbb99449513000cd8/train/javascript">https://www.codewars.com/kata/57a37f3cbb99449513000cd8/train/javascript</a><br> Number(s.replace(/\D/g,’’))</li>
<li><a href="https://www.codewars.com/kata/56a25ba95df27b7743000016/train/javascript">https://www.codewars.com/kata/56a25ba95df27b7743000016/train/javascript</a><br> /^[123]/.test(String(code))</li>
<li><a href="https://www.codewars.com/kata/56a946cd7bd95ccab2000055/train/javascript">https://www.codewars.com/kata/56a946cd7bd95ccab2000055/train/javascript</a><br> str.match(/[a-z]/g) ? str.match(/[a-z]/g).length : 0</li>
</ol>
<h3 id="7-kyu（青铜级）"><a href="#7-kyu（青铜级）" class="headerlink" title="7 kyu（青铜级）"></a>7 kyu（青铜级）</h3><ol>
<li><a href="https://www.codewars.com/kata/559e5b717dd758a3eb00005a/train/javascript">https://www.codewars.com/kata/559e5b717dd758a3eb00005a/train/javascript</a><br>n.replace(/[a-zA-Z]{3,}\b/g, (s) =&gt; <code>$&#123;s.slice(0,1).toUpperCase()&#125;$&#123;s.slice(1,s.length).toLowerCase()&#125;</code>)</li>
<li><a href="https://www.codewars.com/kata/55da6c52a94744b379000036/train/javascript">https://www.codewars.com/kata/55da6c52a94744b379000036/train/javascript</a><br>str.match(/\d+(?!\d])/g) ? str.match(/\d+(?!\d])/g).map(x =&gt; Number(x)).reduce((a,b) =&gt; a + b,0) : 0</li>
<li><a href="https://www.codewars.com/kata/585b1fafe08bae9988000314/train/javascript%EF%BC%88get%E6%98%AF%E8%87%AA%E5%B7%B1%E5%86%99%E7%9A%84%EF%BC%8C%E7%94%A8%E6%9D%A5%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%87%BD%E6%95%B0%EF%BC%89">https://www.codewars.com/kata/585b1fafe08bae9988000314/train/javascript（get是自己写的，用来循环的函数）</a><br>s.match(/\d/g) ? s.match(/\d/g).map(x =&gt; get(x,Number(x))).reduce((a ,b) =&gt; a + b,’’) : ‘’</li>
<li><a href="https://www.codewars.com/kata/55f8a9c06c018a0d6e000132/train/javascript">https://www.codewars.com/kata/55f8a9c06c018a0d6e000132/train/javascript</a><br>/^(\d{4}|\d{6})$/.test(pin)</li>
<li><a href="https://www.codewars.com/kata/57faf32df815ebd49e000117/train/javascript">https://www.codewars.com/kata/57faf32df815ebd49e000117/train/javascript</a><br>string.replace(/(?&lt;=[a-zA-Z])!+/g,’’)</li>
<li><a href="https://www.codewars.com/kata/568dc69683322417eb00002c/train/javascript">https://www.codewars.com/kata/568dc69683322417eb00002c/train/javascript</a><br>(/x[a-z]{0,2}/).test(str) ? str.match(/x[a-z]{0,2}/)[0] === ‘xxx’ : false</li>
<li><a href="https://www.codewars.com/kata/5b39e91ee7a2c103300018b3/train/javascript%EF%BC%88%E6%B2%A1%E5%81%9A%E5%87%BA%E6%9D%A5%EF%BC%89">https://www.codewars.com/kata/5b39e91ee7a2c103300018b3/train/javascript（没做出来）</a><br>s.replace(/\b(\w+)\s(?=\1\b)/g,’’)</li>
<li><a href="https://www.codewars.com/kata/5637b03c6be7e01d99000046/train/javascript">https://www.codewars.com/kata/5637b03c6be7e01d99000046/train/javascript</a><br>map是用来做替换映射的<br>phrase.match(/\w+\b/g).map(item =&gt; map[item.slice(0,1)] || item.slice(0,1)).join(‘’)</li>
<li><a href="https://www.codewars.com/kata/588f5a38ec641b411200005b/train/javascript">https://www.codewars.com/kata/588f5a38ec641b411200005b/train/javascript</a><br>date.match(/\d+(?=/)/)</li>
<li><a href="https://www.codewars.com/kata/52fba66badcd10859f00097e/train/javascript">https://www.codewars.com/kata/52fba66badcd10859f00097e/train/javascript</a><br>str.replace(/[aeiou]/gi,’’)</li>
<li><a href="https://www.codewars.com/kata/5639bdcef2f9b06ce800005b/train/javascript">https://www.codewars.com/kata/5639bdcef2f9b06ce800005b/train/javascript</a><br>s.match(/[a-zA-z]+\b/g).map(item =&gt; item.slice(0,1)).join(‘’)</li>
<li><a href="https://www.codewars.com/kata/55f9064161541a9e01000001/train/javascript">https://www.codewars.com/kata/55f9064161541a9e01000001/train/javascript</a><br>琢磨了半天，似乎是我自己想复杂了…本以为100这种也属于valid number，看了答案发现这种算invalid<br>/^[-+]?\d*.\d{2}$/.test(num)</li>
<li><a href="https://www.codewars.com/kata/5b37a50642b27ebf2e000010/train/javascript">https://www.codewars.com/kata/5b37a50642b27ebf2e000010/train/javascript</a><br>beach.match(/Sand|Water|Fish|sun/ig) ? beach.match(/Sand|Water|Fish|sun/ig).length : 0</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>阅读type-fest源码</title>
    <url>/2021/01/18/%E9%98%85%E8%AF%BBtype-fest%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h1 id="type-fest翻译-amp-源码"><a href="#type-fest翻译-amp-源码" class="headerlink" title="type-fest翻译&amp;源码"></a>type-fest翻译&amp;源码</h1><p>type-fest是一个typeScript类型的集合</p>
<p>test for Vercel</p>
<h2 id="TS基本操作符"><a href="#TS基本操作符" class="headerlink" title="TS基本操作符"></a>TS基本操作符</h2><h3 id="extends（有条件类型）"><a href="#extends（有条件类型）" class="headerlink" title="extends（有条件类型）"></a>extends（有条件类型）</h3><p>typescript 2.8引入了条件类型关键字: extends</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; extends 关键字既可以来扩展已有的类型，也可以对类型进行条件限定，进行条件限定时，用法如下：</span><br><span class="line">&#x2F;&#x2F; 若T能够赋值给U，那么类型是X，否则为Y，具体实现可以看参考阅读</span><br><span class="line">T extends U ? X : Y</span><br></pre></td></tr></table></figure>
<p>参考阅读：<br><a href="https://www.tslang.cn/docs/release-notes/typescript-2.8.html">typeScript有条件类型</a>   </p>
<h3 id="infer（有条件类型中的类型推断）"><a href="#infer（有条件类型中的类型推断）" class="headerlink" title="infer（有条件类型中的类型推断）"></a>infer（有条件类型中的类型推断）</h3><p>在有条件类型的extends子语句中，允许出现infer声明，它会引入一个待推断的类型变量。进行占位，对类型变量进行命名</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 下面代码会提取函数类型的返回值类型</span><br><span class="line">type ReturnType&lt;T&gt; &#x3D; T extends (...args: any[]) &#x3D;&gt; infer R ? R : any;</span><br></pre></td></tr></table></figure>

<h3 id="keyof（获取key）"><a href="#keyof（获取key）" class="headerlink" title="keyof（获取key）"></a>keyof（获取key）</h3><p>获取类型key的联合类型</p>
<h3 id="typeof（获取类型）"><a href="#typeof（获取类型）" class="headerlink" title="typeof（获取类型）"></a>typeof（获取类型）</h3><p>获取类型的字面量类型</p>
<h2 id="TS自带类"><a href="#TS自带类" class="headerlink" title="TS自带类"></a>TS自带类</h2><h3 id="Exclude（常用于去除联合类型中的一部分）"><a href="#Exclude（常用于去除联合类型中的一部分）" class="headerlink" title="Exclude（常用于去除联合类型中的一部分）"></a>Exclude（常用于去除联合类型中的一部分）</h3><p>用法：type A = Exclude&lt;T, U&gt;;<br>输入：T和U这两个范型<br>输出：一个新的type</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">export type Exclude&lt;T, U&gt; &#x3D; T extends U ? never: T;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 例子</span><br><span class="line">type A &#x3D; 1 | 2;</span><br><span class="line">type B &#x3D; 2;</span><br><span class="line">type C &#x3D; Exclude&lt;A, B&gt;;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&gt; 1;</span><br></pre></td></tr></table></figure>
<p>但是根据实现以及例子来看，type A extends type B应该为false，那么应该返回范型T（即type A本身），但结果返回了type A的子集 =&gt; 1<br>即，<br>预期：1 ｜ 2<br>结果：1<br>这是为什么呢？<br>这是因为typeScript中有一种概念叫”naked type parameter”（裸露的类型）它代表着类型没有被其他type包裹<br>其中的区别主要体现在：<br>naked type parameter会将范型拆分一个联合类型，联合类型中的每个成员都会受到影响，最终返回一个最终结果<br>因为 1 | 2，是裸露的类型，所以会依次对比并返回，但如果是非裸露的类型，就不会依次对比（例如被数组包裹）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; naked type parameter（裸露的类型）</span><br><span class="line">type NakedUsage&lt;T&gt; &#x3D; T extends boolean ? &quot;YES&quot; : &quot;NO&quot;</span><br><span class="line">&#x2F;&#x2F; non nakes（被数组包裹的非裸露类型）</span><br><span class="line">type WrappedUsage&lt;T&gt; &#x3D; [T] extends [boolean] ? &quot;YES&quot; : &quot;NO&quot;; &#x2F;&#x2F; wrapped in a tuple</span><br><span class="line"></span><br><span class="line">type Distributed &#x3D; NakedUsage&lt;number | boolean &gt; &#x2F;&#x2F; &#x3D; NakedUsage&lt;number&gt; | NakedUsage&lt;boolean&gt; &#x3D;  &quot;NO&quot; | &quot;YES&quot; </span><br><span class="line">type NotDistributed &#x3D; WrappedUsage&lt;number | boolean &gt; &#x2F;&#x2F; &quot;NO&quot;    </span><br><span class="line">type NotDistributed2 &#x3D; WrappedUsage&lt;boolean &gt; &#x2F;&#x2F; &quot;YES&quot;</span><br></pre></td></tr></table></figure>

<h3 id="Extract"><a href="#Extract" class="headerlink" title="Extract"></a>Extract</h3><p>与Exclude相对的是Extract</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">type Extract&lt;T, U&gt; &#x3D; T extends U ? T : never</span><br></pre></td></tr></table></figure>

<p>参考阅读：<br><a href="https://stackoverflow.com/questions/51651499/typescript-what-is-a-naked-type-parameter/51651684#51651684">typescript: what is a “naked type parameter”</a><br><a href="https://www.tslang.cn/docs/release-notes/typescript-2.8.html">typescript 2.8 分布式有条件类型</a></p>
<h3 id="其他自带类（Pick，Record，Partial等）"><a href="#其他自带类（Pick，Record，Partial等）" class="headerlink" title="其他自带类（Pick，Record，Partial等）"></a>其他自带类（Pick，Record，Partial等）</h3><p>Pick（根据key返回一个子类型）<br>Omit（Pick与Exclude的组合，根据key舍弃类型，剩余的key组成一个子类型返回）<br>Record（根据key改写类型，并返回）<br>Partial（范型接受一个类型，将类型中的key变得可以缺失）<br>Required（范型接受一个类型，将类型中的key变得必须存在）<br>Readonly（范型接受一个类型，将类型中的key变得只读）</p>
<h2 id="type-fest工具类"><a href="#type-fest工具类" class="headerlink" title="type-fest工具类"></a>type-fest工具类</h2><h3 id="Except（丢弃object-type的某些keys，生成一个新的type。是更严格的Omit）"><a href="#Except（丢弃object-type的某些keys，生成一个新的type。是更严格的Omit）" class="headerlink" title="Except（丢弃object type的某些keys，生成一个新的type。是更严格的Omit）"></a>Except（丢弃object type的某些keys，生成一个新的type。是更严格的Omit）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">export type Except&lt;ObjectType, KeysType extends keyof ObjectType&gt; &#x3D;</span><br><span class="line">Pick&lt;ObjectType, Exclude&lt;keyof ObjectType, KeysType&gt;&gt;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 例子</span><br><span class="line">type Foo &#x3D; &#123;</span><br><span class="line">	a: number;</span><br><span class="line">	b: string;</span><br><span class="line">	c: boolean;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type FooWithoutA &#x3D; Except&lt;Foo, &#39;a&#39; | &#39;c&#39;&gt;;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&gt; &#123;b: string&#125;;</span><br></pre></td></tr></table></figure>
<p>对比实现可以发现，Except对于key的限制更紧，必须是keyof ObjectType的子集。而Omit则没有限制</p>
<h3 id="Mutable（将原类型中的readonly属性移除，和Readonly作用相反）"><a href="#Mutable（将原类型中的readonly属性移除，和Readonly作用相反）" class="headerlink" title="Mutable（将原类型中的readonly属性移除，和Readonly作用相反）"></a>Mutable（将原类型中的readonly属性移除，和Readonly作用相反）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">export type Mutable&lt;ObjectType&gt; &#x3D; &#123;</span><br><span class="line">	-readonly [KeyType in keyof ObjectType]: ObjectType[KeyType];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 例子</span><br><span class="line">type Foo &#x3D; &#123;</span><br><span class="line">	readonly a: number;</span><br><span class="line">	readonly b: string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const mutableFoo: Mutable&lt;Foo&gt; &#x3D; &#123;a: 1, b: &#39;2&#39;&#125;;</span><br><span class="line">mutableFoo.a &#x3D; 3;</span><br></pre></td></tr></table></figure>

<h3 id="Merge（FirstType与SecondType的融合，SecondType会覆盖重复的部分）"><a href="#Merge（FirstType与SecondType的融合，SecondType会覆盖重复的部分）" class="headerlink" title="Merge（FirstType与SecondType的融合，SecondType会覆盖重复的部分）"></a>Merge（FirstType与SecondType的融合，SecondType会覆盖重复的部分）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">export type Merge&lt;FirstType, SecondType&gt; &#x3D; </span><br><span class="line">Except&lt;FirstType, Extract&lt;keyof FirstType, keyof SecondType&gt;&gt; &amp; SecondType;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 例子</span><br><span class="line">type Foo &#x3D; &#123;</span><br><span class="line">	a: number;</span><br><span class="line">	b: string;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">type Bar &#x3D; &#123;</span><br><span class="line">	b: number;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const ab: Merge&lt;Foo, Bar&gt; &#x3D; &#123;a: 1, b: 2&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="MergeExclusive（限定更紧的type联合类型）"><a href="#MergeExclusive（限定更紧的type联合类型）" class="headerlink" title="MergeExclusive（限定更紧的type联合类型）"></a>MergeExclusive（限定更紧的type联合类型）</h3><p>如果FirstType和SecondType都是基本数据类型，则返回或的联合数据类型<br>否则使用FirstType或SecondType的联合类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 内部实现Without（将FirstType的特有属性，变成never，构成一个子类型返回）（为了方便移除特有属性）</span><br><span class="line">type Without&lt;FirstType, SecondType&gt; &#x3D; &#123;[KeyType in Exclude&lt;keyof FirstType, keyof SecondType&gt;]?: never&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; MergeExclusive实现</span><br><span class="line">&#x2F;&#x2F; 注意(FirstType | SecondType)这里是一个整体、联合类型</span><br><span class="line">export type MergeExclusive&lt;FirstType, SecondType&gt; &#x3D;</span><br><span class="line">	(FirstType | SecondType) extends object ?</span><br><span class="line">		(Without&lt;FirstType, SecondType&gt; &amp; SecondType) | (Without&lt;SecondType, FirstType&gt; &amp; FirstType) :</span><br><span class="line">		FirstType | SecondType;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 例子</span><br><span class="line">interface ExclusiveVariation1 &#123;</span><br><span class="line">	exclusive1: boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">interface ExclusiveVariation2 &#123;</span><br><span class="line">	exclusive2: string;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ExclusiveOptions &#x3D; MergeExclusive&lt;ExclusiveVariation1, ExclusiveVariation2&gt;;</span><br><span class="line">&#x2F;&#x2F; never &amp; ExclusiveVariation2 | nerver &amp; ExclusiveVariation1</span><br><span class="line">let exclusiveOptions: ExclusiveOptions;</span><br><span class="line"></span><br><span class="line">exclusiveOptions &#x3D; &#123;exclusive1: true&#125;;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&gt; Works</span><br><span class="line">exclusiveOptions &#x3D; &#123;exclusive2: &#39;hi&#39;&#125;;</span><br><span class="line">&#x2F;&#x2F;&#x3D;&gt; Works</span><br><span class="line">exclusiveOptions &#x3D; &#123;exclusive1: true, exclusive2: &#39;hi&#39;&#125;;</span><br></pre></td></tr></table></figure>
<p>对比实现可发现，相比于普通的联合类型，MergeExclusive限定更紧，不能同时持有2个类型</p>
<h3 id="RequireAtLeastOne（根据key，使原类型中属性，任意且至少一个变为必选，剩余的变为可选）"><a href="#RequireAtLeastOne（根据key，使原类型中属性，任意且至少一个变为必选，剩余的变为可选）" class="headerlink" title="RequireAtLeastOne（根据key，使原类型中属性，任意且至少一个变为必选，剩余的变为可选）"></a>RequireAtLeastOne（根据key，使原类型中属性，任意且至少一个变为必选，剩余的变为可选）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">&#x2F;&#x2F; 第一个参数为范型T，第二个参数是key的子集，如果不填则默认为全部的key</span><br><span class="line">export type RequireAtLeastOne&lt;</span><br><span class="line">	ObjectType,</span><br><span class="line">	KeysType extends keyof ObjectType &#x3D; keyof ObjectTypef</span><br><span class="line">&gt; &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; 根据key使得一个key变得必选（个人感觉 -? 在这里没有用，有知道的hxd可以评论区讨论一下）</span><br><span class="line">	[Key in KeysType]-?: Required&lt;Pick&lt;ObjectType, Key&gt;&gt; &amp;</span><br><span class="line">    &#x2F;&#x2F; 其他key变得可选</span><br><span class="line">	Partial&lt;Pick&lt;ObjectType, Exclude&lt;KeysType, Key&gt;&gt;&gt;;</span><br><span class="line">&#x2F;&#x2F; 将type对象合并为联合类型返回（这样做才能实现任意一个key）</span><br><span class="line">&#125;[KeysType] &amp;</span><br><span class="line">	&#x2F;&#x2F; 未被传入的其他的key保持不变</span><br><span class="line">	Except&lt;ObjectType, KeysType&gt;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 例子</span><br><span class="line">interface User &#123;</span><br><span class="line">  name: string;</span><br><span class="line">  age: number;</span><br><span class="line">  gender: string;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &#x3D;&gt; </span><br><span class="line">&#x2F;&#x2F;  &#123;</span><br><span class="line">&#x2F;&#x2F;    name: string;</span><br><span class="line">&#x2F;&#x2F;    age: number;</span><br><span class="line">&#x2F;&#x2F;    gender?: string;</span><br><span class="line">&#x2F;&#x2F;  &#125; |</span><br><span class="line">&#x2F;&#x2F;  &#123;</span><br><span class="line">&#x2F;&#x2F;    name: string;</span><br><span class="line">&#x2F;&#x2F;    age: number;</span><br><span class="line">&#x2F;&#x2F;    gender?: string;</span><br><span class="line">&#x2F;&#x2F;  &#125;;</span><br><span class="line">type Test &#x3D; RequireAtLeastOne&lt;User, &#39;name&#39; | &#39;age&#39;&gt;</span><br><span class="line">&#x2F;&#x2F; 错误，name或age应该至少存在一个</span><br><span class="line">const error: Test &#x3D; &#123;</span><br><span class="line">  gender: &#39;male&#39;,</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 正确，存在name</span><br><span class="line">const correct1: Test &#x3D; &#123;</span><br><span class="line">  gender: &#39;male&#39;,</span><br><span class="line">  name: &#39;correct&#39;,</span><br><span class="line">&#125;;</span><br><span class="line">&#x2F;&#x2F; 正确</span><br><span class="line">const correct2: Test &#x3D; &#123;</span><br><span class="line">  gender: &#39;male&#39;,</span><br><span class="line">  age: 1,</span><br><span class="line">  name: &#39;correct&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="RequireExactlyOne（根据key，使原类型中属性，任意且只有一个变为必选，剩余的变为不可选）"><a href="#RequireExactlyOne（根据key，使原类型中属性，任意且只有一个变为必选，剩余的变为不可选）" class="headerlink" title="RequireExactlyOne（根据key，使原类型中属性，任意且只有一个变为必选，剩余的变为不可选）"></a>RequireExactlyOne（根据key，使原类型中属性，任意且只有一个变为必选，剩余的变为不可选）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">&#x2F;&#x2F; typeScript &gt;&#x3D;3.5 _Omit将被移除（ts3.5 内部实现了Omit）</span><br><span class="line">type _Omit&lt;T, K extends keyof any&gt; &#x3D; Pick&lt;T, Exclude&lt;keyof T, K&gt;&gt;;</span><br><span class="line">export type RequireExactlyOne&lt;ObjectType, KeysType extends keyof ObjectType &#x3D; keyof ObjectType&gt; &#x3D;</span><br><span class="line">	&#123;[Key in KeysType]: (</span><br><span class="line">		Required&lt;Pick&lt;ObjectType, Key&gt;&gt; &amp;</span><br><span class="line">		Partial&lt;Record&lt;Exclude&lt;KeysType, Key&gt;, never&gt;&gt;</span><br><span class="line">	)&#125;[KeysType] &amp; _Omit&lt;ObjectType, KeysType&gt;;</span><br><span class="line">&#x2F;&#x2F; 例子</span><br></pre></td></tr></table></figure>

<h3 id="PartialDeep（深度Partial，将基本数据类型、Map、Set等嵌套数据结构进行Partial操作）"><a href="#PartialDeep（深度Partial，将基本数据类型、Map、Set等嵌套数据结构进行Partial操作）" class="headerlink" title="PartialDeep（深度Partial，将基本数据类型、Map、Set等嵌套数据结构进行Partial操作）"></a>PartialDeep（深度Partial，将基本数据类型、Map、Set等嵌套数据结构进行Partial操作）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;实现</span><br><span class="line">export type PartialDeep&lt;T&gt; &#x3D; T extends Primitive</span><br><span class="line">	? Partial&lt;T&gt;</span><br><span class="line">	: T extends Map&lt;infer KeyType, infer ValueType&gt;</span><br><span class="line">	? PartialMapDeep&lt;KeyType, ValueType&gt;</span><br><span class="line">	: T extends Set&lt;infer ItemType&gt;</span><br><span class="line">	? PartialSetDeep&lt;ItemType&gt;</span><br><span class="line">	: T extends ReadonlyMap&lt;infer KeyType, infer ValueType&gt;</span><br><span class="line">	? PartialReadonlyMapDeep&lt;KeyType, ValueType&gt;</span><br><span class="line">	: T extends ReadonlySet&lt;infer ItemType&gt;</span><br><span class="line">	? PartialReadonlySetDeep&lt;ItemType&gt;</span><br><span class="line">	: T extends ((...arguments: any[]) &#x3D;&gt; unknown)</span><br><span class="line">	? T | undefined</span><br><span class="line">	: T extends object</span><br><span class="line">	? PartialObjectDeep&lt;T&gt;</span><br><span class="line">	: unknown;</span><br><span class="line">&#x2F;&#x2F;例子</span><br></pre></td></tr></table></figure>

<h3 id="ReadonlyDeep（深度Readonly，将基本数据类型、Map、Set等嵌套数据结构进行Readonly操作）"><a href="#ReadonlyDeep（深度Readonly，将基本数据类型、Map、Set等嵌套数据结构进行Readonly操作）" class="headerlink" title="ReadonlyDeep（深度Readonly，将基本数据类型、Map、Set等嵌套数据结构进行Readonly操作）"></a>ReadonlyDeep（深度Readonly，将基本数据类型、Map、Set等嵌套数据结构进行Readonly操作）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ...</span><br></pre></td></tr></table></figure>

<h3 id="LiteralUnion（兼容-基本数据类型与字面量类型的联合数据类型-IDE自动提示补全）"><a href="#LiteralUnion（兼容-基本数据类型与字面量类型的联合数据类型-IDE自动提示补全）" class="headerlink" title="LiteralUnion（兼容 基本数据类型与字面量类型的联合数据类型 IDE自动提示补全）"></a>LiteralUnion（兼容 基本数据类型与字面量类型的联合数据类型 IDE自动提示补全）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">export type LiteralUnion&lt;</span><br><span class="line">	LiteralType,</span><br><span class="line">	BaseType extends Primitive</span><br><span class="line">&gt; &#x3D; LiteralType | (BaseType &amp; &#123;_?: never&#125;);</span><br><span class="line">&#x2F;&#x2F; 例子（webstorm不提示，然而vscode适用）</span><br><span class="line">type Pet &#x3D; &#39;dog&#39; | &#39;cat&#39; | string;</span><br><span class="line">const pet: Pet &#x3D; &#39;&#39;; &#x2F;&#x2F; 不会自动提示dog和cat</span><br><span class="line"></span><br><span class="line">type Pet2 &#x3D; LiteralUnion&lt;&#39;dog&#39; | &#39;cat&#39;, string&gt;;</span><br><span class="line">const pet: Pet2 &#x3D; &#39;&#39;; &#x2F;&#x2F; 会自动提示dog和cat</span><br></pre></td></tr></table></figure>

<h3 id="Promisable（代表value以及被PromiseLike包裹的value的type）"><a href="#Promisable（代表value以及被PromiseLike包裹的value的type）" class="headerlink" title="Promisable（代表value以及被PromiseLike包裹的value的type）"></a>Promisable（代表value以及被PromiseLike包裹的value的type）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">export type Promisable&lt;T&gt; &#x3D; T | PromiseLike&lt;T&gt;;</span><br><span class="line">&#x2F;&#x2F; PromiseLike是ts定义的interface，定义了面向Promise的结构</span><br><span class="line">&#x2F;&#x2F; 例子</span><br><span class="line">async function logger(getLogEntry: () &#x3D;&gt; Promisable&lt;string&gt;): Promise&lt;void&gt; &#123;</span><br><span class="line">    const entry &#x3D; await getLogEntry();</span><br><span class="line">    console.log(entry);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">logger(() &#x3D;&gt; &#39;foo&#39;);</span><br><span class="line">logger(() &#x3D;&gt; Promise.resolve(&#39;bar&#39;));</span><br></pre></td></tr></table></figure>

<h3 id="Opaque（不透明的类型）"><a href="#Opaque（不透明的类型）" class="headerlink" title="Opaque（不透明的类型）"></a>Opaque（不透明的类型）</h3><p>感觉不太实用，加Token用来区分基本数据类型，不同Token代表不同的类型，相同的Token则可以相互赋值<br>（例如字符串代表的含义不同？名字和住址不可以相互赋值，但英文名和中文可以相互赋值）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">export type Opaque&lt;Type, Token &#x3D; unknown&gt; &#x3D; Type &amp; &#123;readonly __opaque__: Token&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="SetOptional（有选择的Partial）"><a href="#SetOptional（有选择的Partial）" class="headerlink" title="SetOptional（有选择的Partial）"></a>SetOptional（有选择的Partial）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">export type SetOptional&lt;BaseType, Keys extends keyof BaseType&gt; &#x3D;</span><br><span class="line">	Simplify&lt;</span><br><span class="line">		&#x2F;&#x2F; 必选的key组成的type</span><br><span class="line">		Except&lt;BaseType, Keys&gt; &amp;</span><br><span class="line">		&#x2F;&#x2F; 可选的key组成的type</span><br><span class="line">		Partial&lt;Pick&lt;BaseType, Keys&gt;&gt;</span><br><span class="line">	&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="SomeRequired（SetOptional的姊妹类型，使type的部分key变得必须）"><a href="#SomeRequired（SetOptional的姊妹类型，使type的部分key变得必须）" class="headerlink" title="SomeRequired（SetOptional的姊妹类型，使type的部分key变得必须）"></a>SomeRequired（SetOptional的姊妹类型，使type的部分key变得必须）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">export type SetRequired&lt;BaseType, Keys extends keyof BaseType&gt; &#x3D;</span><br><span class="line">	Simplify&lt;</span><br><span class="line">		Except&lt;BaseType, Keys&gt; &amp;</span><br><span class="line">		Required&lt;Pick&lt;BaseType, Keys&gt;&gt;</span><br><span class="line">	&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="ValueOf（接受一个类型范型T，返回T的value联合类型）"><a href="#ValueOf（接受一个类型范型T，返回T的value联合类型）" class="headerlink" title="ValueOf（接受一个类型范型T，返回T的value联合类型）"></a>ValueOf（接受一个类型范型T，返回T的value联合类型）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">export type ValueOf&lt;ObjectType, ValueType extends keyof ObjectType &#x3D; keyof ObjectType&gt; &#x3D; ObjectType[ValueType];</span><br></pre></td></tr></table></figure>

<h3 id="PromiseValue-获取promise值的type"><a href="#PromiseValue-获取promise值的type" class="headerlink" title="PromiseValue(获取promise值的type)"></a>PromiseValue(获取promise值的type)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">export type PromiseValue&lt;PromiseType, Otherwise &#x3D; PromiseType&gt; &#x3D; PromiseType extends Promise&lt;infer Value&gt;</span><br><span class="line">	? &#123; 0: PromiseValue&lt;Value&gt;; 1: Value &#125;[PromiseType extends Promise&lt;unknown&gt; ? 0 : 1]</span><br><span class="line">	: Otherwise;</span><br></pre></td></tr></table></figure>

<h3 id="AsyncReturnType（获取异步函数返回值的type）"><a href="#AsyncReturnType（获取异步函数返回值的type）" class="headerlink" title="AsyncReturnType（获取异步函数返回值的type）"></a>AsyncReturnType（获取异步函数返回值的type）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">&#x2F;&#x2F; ts内部实现ReturnType（获取函数返回值类型）</span><br><span class="line">type ReturnType&lt;T extends (...args: any) &#x3D;&gt; any&gt; &#x3D; T extends (...args: any) &#x3D;&gt; infer R ? R : any;</span><br><span class="line"></span><br><span class="line">export type AsyncReturnType&lt;Target extends AsyncFunction&gt; &#x3D; PromiseValue&lt;ReturnType&lt;Target&gt;&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="ConditionalKeys（返回符合条件的key）"><a href="#ConditionalKeys（返回符合条件的key）" class="headerlink" title="ConditionalKeys（返回符合条件的key）"></a>ConditionalKeys（返回符合条件的key）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">&#x2F;&#x2F; ts内部实现NonNullable（排除null和undefined）</span><br><span class="line">type NonNullable&lt;T&gt; &#x3D; T extends null | undefined ? never : T;</span><br><span class="line"></span><br><span class="line">export type ConditionalKeys&lt;Base, Condition&gt; &#x3D; NonNullable&lt;</span><br><span class="line">	&#123;</span><br><span class="line">		&#x2F;&#x2F; Map through all the keys of the given base type.</span><br><span class="line">		[Key in keyof Base]:</span><br><span class="line">			&#x2F;&#x2F; 根据Condition筛选</span><br><span class="line">			Base[Key] extends Condition</span><br><span class="line">				? Key</span><br><span class="line">				: never;</span><br><span class="line">    &#x2F;&#x2F; 将结果type转为union type</span><br><span class="line">	&#125;[keyof Base]</span><br><span class="line">&gt;;</span><br><span class="line">&#x2F;&#x2F; 例子</span><br><span class="line">interface Example &#123;</span><br><span class="line">	a: string;</span><br><span class="line">	b: string | number;</span><br><span class="line">	c?: string;</span><br><span class="line">	d: &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line">type StringKeysOnly &#x3D; ConditionalKeys&lt;Example, string&gt;;</span><br><span class="line">&#x2F;&#x2F; 非空且类型为string的只有a  reuslt &#x3D;&gt; &#39;a&#39;</span><br></pre></td></tr></table></figure>

<h3 id="ConditionalPick（返回符合条件的key组成的type）"><a href="#ConditionalPick（返回符合条件的key组成的type）" class="headerlink" title="ConditionalPick（返回符合条件的key组成的type）"></a>ConditionalPick（返回符合条件的key组成的type）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">export type ConditionalPick&lt;Base, Condition&gt; &#x3D; Pick&lt;</span><br><span class="line">	Base,</span><br><span class="line">	ConditionalKeys&lt;Base, Condition&gt;</span><br><span class="line">&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="ConditionalExcept（返回不符合条件的key组成的type）"><a href="#ConditionalExcept（返回不符合条件的key组成的type）" class="headerlink" title="ConditionalExcept（返回不符合条件的key组成的type）"></a>ConditionalExcept（返回不符合条件的key组成的type）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">export type ConditionalExcept&lt;Base, Condition&gt; &#x3D; Except&lt;</span><br><span class="line">	Base,</span><br><span class="line">	ConditionalKeys&lt;Base, Condition&gt;</span><br><span class="line">&gt;;</span><br></pre></td></tr></table></figure>

<h3 id="UnionToIntersection（将联合类型变为交叉类型）"><a href="#UnionToIntersection（将联合类型变为交叉类型）" class="headerlink" title="UnionToIntersection（将联合类型变为交叉类型）"></a>UnionToIntersection（将联合类型变为交叉类型）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">export type UnionToIntersection&lt;Union&gt; &#x3D; (</span><br><span class="line">    &#x2F;&#x2F; extends unknown返回总是true，构造一个联合的函数类型，进而返回一个交叉类型</span><br><span class="line">	Union extends unknown</span><br><span class="line">		? (distributedUnion: Union) &#x3D;&gt; void</span><br><span class="line">		: never</span><br><span class="line">	) extends ((mergedIntersection: infer Intersection) &#x3D;&gt; void)</span><br><span class="line">        &#x2F;&#x2F; 将联合类型转为交叉类型</span><br><span class="line">		? Intersection</span><br><span class="line">		: never;</span><br></pre></td></tr></table></figure>

<h3 id="Stringified（将type中的类型全部变为string）"><a href="#Stringified（将type中的类型全部变为string）" class="headerlink" title="Stringified（将type中的类型全部变为string）"></a>Stringified（将type中的类型全部变为string）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">export type Stringified&lt;ObjectType&gt; &#x3D; &#123;[KeyType in keyof ObjectType]: string&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="FixedLengthArray（长度不可变的数组）"><a href="#FixedLengthArray（长度不可变的数组）" class="headerlink" title="FixedLengthArray（长度不可变的数组）"></a>FixedLengthArray（长度不可变的数组）</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">&#x2F;&#x2F; 需要排除的方法</span><br><span class="line">type ArrayLengthMutationKeys &#x3D; &#39;splice&#39; | &#39;push&#39; | &#39;pop&#39; | &#39;shift&#39; | &#39;unshift&#39;;</span><br><span class="line">export type FixedLengthArray&lt;Element, Length extends number, ArrayPrototype &#x3D; [Element, ...Element[]]&gt; &#x3D; Pick&lt;</span><br><span class="line">	ArrayPrototype,</span><br><span class="line">	Exclude&lt;keyof ArrayPrototype, ArrayLengthMutationKeys&gt;</span><br><span class="line">&gt; &amp; &#123;</span><br><span class="line">	[index: number]: Element;</span><br><span class="line">	[Symbol.iterator]: () &#x3D;&gt; IterableIterator&lt;Element&gt;;</span><br><span class="line">	readonly length: Length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="react类型源码"><a href="#react类型源码" class="headerlink" title="react类型源码"></a>react类型源码</h1><h2 id="工具类型"><a href="#工具类型" class="headerlink" title="工具类型"></a>工具类型</h2><h3 id="InferableComponentEnhancerWithProps"><a href="#InferableComponentEnhancerWithProps" class="headerlink" title="InferableComponentEnhancerWithProps"></a>InferableComponentEnhancerWithProps</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 实现</span><br><span class="line">&#x2F;&#x2F; Matching&lt;TInjectedProps, GetProps&lt;C&gt;&gt;，选出</span><br><span class="line">&#x2F;&#x2F; type是一个函数类型，参数是一个组件</span><br><span class="line">export type InferableComponentEnhancerWithProps&lt;TInjectedProps, TNeedsProps&gt; &#x3D;</span><br><span class="line">    &lt;C extends ComponentType&lt;Matching&lt;TInjectedProps, GetProps&lt;C&gt;&gt;&gt;&gt;(</span><br><span class="line">        component: C</span><br><span class="line">    ) &#x3D;&gt; ConnectedComponentClass&lt;C, Omit&lt;GetProps&lt;C&gt;, keyof Shared&lt;TInjectedProps, GetProps&lt;C&gt;&gt;&gt; &amp; TNeedsProps&gt;;</span><br></pre></td></tr></table></figure>


<div id="gitalk-container"></div>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">
<script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>
<script src="/js/md5.min.js"></script>
<script >
var gitalk = new Gitalk({
  clientID: '690f7443a587c05ba6f5',
  clientSecret: '5702fe23820d4464abfd4e2f9a736da2565ae3c9',
  repo: 'haoyanwang.github.io',
  owner: 'haoyanwang',
  admin: ['haoyanwang'],
  id: md5(location.pathname),  
  distractionFreeMode: false,
});
gitalk.render('gitalk-container')
</script>
]]></content>
  </entry>
  <entry>
    <title>从字段联动中学图算法</title>
    <url>/2023/02/01/%E4%BB%8E%E5%AD%97%E6%AE%B5%E8%81%94%E5%8A%A8%E4%B8%AD%E5%AD%A6%E5%9B%BE%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h1 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h1><p>字段联动是很常见的表单需求</p>
<p>最基本的是主动模式联动显示，即表单项决定其他表单项的显示和隐藏，使用效果例如：</p>
<p>请选择您要申请的职位</p>
<pre><code>- if 前端 请选择您使用的技术框架： Vue React Angular
- else if 后端 请选择您使用的语言： Java Python PHP</code></pre>
<p>当然除了主动模式，还有被动模式，即表单项被其他表单项决定</p>
<p>除了联动显示，还可能有联动禁用、联动只读等</p>
<h2 id="直觉code，best-code"><a href="#直觉code，best-code" class="headerlink" title="直觉code，best code"></a>直觉code，best code</h2><p>业务现存的表单结构为: {题目合集: [{标题、类型、结果、选项}, {标题、类型、结果、选项}]}</p>
<p>因为数据结构为数组，所以第一反应就是遍历，根据联动关系，算出题目是隐藏还是显示。并设计出了主动模式下的联动关系的数据结构:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; - 当题目1的value为A时，显示题目2、当题目1的value为B时，显示题目3</span><br><span class="line">&#x2F;&#x2F; - 当题目2的value为A时，显示题目3</span><br><span class="line"></span><br><span class="line">[&#123;id: &#39;1&#39;, linkages: [&#123;id: &#39;2&#39;, value: A, id: &#39;3&#39;, value: B&#125;]&#125;, &#123;id: &#39;2&#39;, linkages: [&#123;id: &#39;3&#39;, value: A&#125;]&#125;]</span><br></pre></td></tr></table></figure>

<p>于是便写出了第一版实现</p>
<pre><code>1. 根据主动联动关系，计算出被动联动关系（题目2被题目1的1联动显示。题目3被题目1的2、题目2的1联动显示）
2. 每次变化时，遍历所有的题目，根据联动关系计算出每一道题是否隐藏（invisible）（只有当有被联动关系，并且被联动关系均不满足，则这道题隐藏）</code></pre>
<p>但是很快就遇到了问题，因为遍历是有顺序的（数组从前往后），但联动是没有顺序的，所以单纯的遍历很有可能计算出不对的结果</p>
<pre><code>eg.

有1、2、3三道题
联动关系：
当2选择A时，显示1
当3选择A时，显示2、当3选择B时，显示1

3(A) → 2
3(B) → 1
2(A) → 1
当题目3选择A、题目2选择A时 1、2、3三道题均可见。这时将题目3改为C，题目1、2均应隐藏。
但因遍历顺序的问题，计算到题目1的时候，题目2仍未计算，仍是可见的。则计算出了错误的结果。即题目1显示、题目2隐藏、题目3为C</code></pre>
<p>于是为了解决上述问题，便有了第二版实现，多层级遍历</p>
<p>即先把题目2是否显示计算出来，再进行一次遍历，将题目1是否显示计算出来。便引出了一个概念：linkageLevel，联动层级</p>
<p>在上述问题中，题目3为1级、题目2为2级、题目1为2级（被题目3联动）或3级（被题目2联动），先计算出题目中的最大联动层级，再进行多次遍历。第一次遍历计算出题目2是否显示，第二次遍历计算出题目1是否显示</p>
<p>但假如存在环状联动，这种方法又遇到了瓶颈，甚至可能会出现死循环</p>
<p>时间复杂度：题目数量为n，最大联动层级为m  O(n^m) 非常恐怖的复杂度</p>
<p>于是考虑从图算法的角度出发，利用拓扑排序去解决计算的问题</p>
<h2 id="图论算法实现联动"><a href="#图论算法实现联动" class="headerlink" title="图论算法实现联动"></a>图论算法实现联动</h2><p>分析一下联动关系的数据结构，可以发现，其实就是一副有向有环图</p>
<p>其中题目就是图中的节点，联动关系就是边。并且是带方向，可能存在环状的</p>
<p>而我们的需求是，根据联动关系，计算所有题目显示或隐藏，既寻找该数据结构的拓扑排序</p>
<p>可以参考leetcode这道题 <a href="https://leetcode.cn/problems/course-schedule-ii/">https://leetcode.cn/problems/course-schedule-ii/</a></p>
<p>求拓扑排序分为两种思路：BFS（广度优先遍历）、DFS（深度优先遍历）</p>
<p>有向无环图一定存在拓扑排序，而有向有环图一定不存在拓扑排序，所以我们要先判断图是否有环</p>
<p>广度优先：</p>
<pre><code>在广度优先遍历中，出入度是核心概念：如果一个节点 x 有 a 条边指向别的节点，同时被 b 条边所指，则称节点 x 的出度为 a，入度为 b
在联动关系中，入度为0表示不被联动，既无条件显示的题目

算法思路：
1. 构建一个 indegree 数组记录每个节点的入度，即 indegree[i] 记录节点 i 的入度
2. 对 BFS 队列进行初始化，将入度为 0 的节点首先装入队列
3. 开始执行 BFS 循环，不断弹出队列中的节点，减少相邻节点的入度，并将入度变为 0 的节点加入队列
4.如果最终所有节点都被遍历过（count 等于节点数），则说明不存在环，反之则说明存在环
5. 最终队列中的节点顺序就是图的拓扑排序
6. 根据拓扑排序顺序，去求题目是否隐藏，如果有环则把环内节点跳过，并置为不显示

参考资料及示意图： https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/huan-jian--e36de/#环检测算法bfs-版本

时间复杂度：n个节点 m条边 O(n+m)</code></pre>
<p>深度优先：</p>
<pre><code>环检测：从节点开始递归遍历，记录访问过的节点与当前路径。如果节点访问过，则直接跳过，如果当前路径与当前节点有重合，则存在环
遍历思路：后序遍历反转就是拓扑排序
个人觉得不如bfs好理解

参考资料：https://labuladong.gitee.io/algo/di-yi-zhan-da78c/shou-ba-sh-03a72/huan-jian--e36de/#拓扑排序算法dfs-版本</code></pre>
]]></content>
  </entry>
</search>
